--- yadex-1.7.0.orig/README
+++ yadex-1.7.0/README
@@ -1,4 +1,4 @@
-Yadex 1.7.0 (2003-12-28)
+Yadex 1.7.0 (2011-01-05)
 
 WHAT IS YADEX ?
     Yadex is a Doom level (wad) editor for Unix systems running X,
--- yadex-1.7.0.orig/configure
+++ yadex-1.7.0/configure
@@ -1,7 +1,7 @@
 #!/bin/sh
 #
-#	configure - configure script for Yadex
-#	AYM 2002-09-15
+#    configure - configure script for Yadex
+#    AYM 2002-09-15
 #
 
 # This file is copyright André Majorel 2002-2003.
@@ -30,13 +30,13 @@
 HAVE_NANOSLEEP=
 HAVE_SNPRINTF=
 HAVE_USLEEP=
-INTERFACE=x11				# "bgi" or "x11"
-PLATFORM=unix				# "dos" or "unix"
+INTERFACE=x11                # "bgi" or "x11"
+PLATFORM=unix                # "dos" or "unix"
 PREFIX=/usr/local
 
 
 #
-#	check - perform a test
+#    check - perform a test
 #
 check () {
   cdir=/tmp
@@ -60,7 +60,7 @@
 
 
 #
-#	genc - generate config.cc
+#    genc - generate config.cc
 #
 genc () {
   pathname=$BUILDDIR/config.cc
@@ -88,7 +88,7 @@
 
 
 #
-#	genbool - generate a boolean macro definition
+#    genbool - generate a boolean macro definition
 #
 genbool () {
   name=$1
@@ -101,7 +101,7 @@
 
 
 #
-#	genh - generate config.h
+#    genh - generate config.h
 #
 genh () {
   pathname=$BUILDDIR/config.h
@@ -112,25 +112,25 @@
     echo
     case "$PLATFORM" in
       dos)
-	echo '#define Y_DOS'
-	echo '//#define Y_UNIX';;
+    echo '#define Y_DOS'
+    echo '//#define Y_UNIX';;
       unix)
-	echo '//#define Y_DOS'
-	echo '#define Y_UNIX';;
+    echo '//#define Y_DOS'
+    echo '#define Y_UNIX';;
       *)
-	echo "configure: bad \$PLATFORM \"$PLATFORM\"" >&2
-	exit 1;;
+    echo "configure: bad \$PLATFORM \"$PLATFORM\"" >&2
+    exit 1;;
     esac
     case "$INTERFACE" in
       bgi)
-	echo '#define Y_BGI'
-	echo '//#define Y_X11';;
+    echo '#define Y_BGI'
+    echo '//#define Y_X11';;
       x11)
-	echo '//#define Y_BGI'
-	echo '#define Y_X11';;
+    echo '//#define Y_BGI'
+    echo '#define Y_X11';;
       *)
-	echo "configure: bad \$INTERFACE \"$INTERFACE\"" >&2
-	exit 1;;
+    echo "configure: bad \$INTERFACE \"$INTERFACE\"" >&2
+    exit 1;;
     esac
     genbool GETTIMEOFDAY
     genbool NANOSLEEP
@@ -146,7 +146,7 @@
 
 
 #
-#	Parse the command line
+#    Parse the command line
 #
 while [ "$#" -ge 1 ]
 do
@@ -162,8 +162,8 @@
       shift
       if [ "$#" -lt 1 ]
       then
-	echo "configure: --cc requires an argument" 1>&2
-	exit 1
+    echo "configure: --cc requires an argument" 1>&2
+    exit 1
       fi
       CC="$1"
       ;;
@@ -176,8 +176,8 @@
       shift
       if [ "$#" -lt 1 ]
       then
-	echo "configure: --cxx requires an argument" 1>&2
-	exit 1
+    echo "configure: --cxx requires an argument" 1>&2
+    exit 1
       fi
       CXX="$1"
       ;;
@@ -190,8 +190,8 @@
       shift
       if [ "$#" -lt 1 ]
       then
-	echo "configure: --prefix requires an argument" 1>&2
-	exit 1
+    echo "configure: --prefix requires an argument" 1>&2
+    exit 1
       fi
       PREFIX="$1"
       ;;
@@ -213,7 +213,7 @@
 done
 
 #
-#	Sanity checks
+#    Sanity checks
 #
 if expr "x$PREFIX" : x/ >/dev/null
 then
@@ -228,12 +228,12 @@
 [ -x $GREP ] || GREP=grep
 
 #
-#	Look for a C compiler
+#    Look for a C compiler
 #
-#	We try "gcc" first as commercial Unixen often have a bundled
-#	"cc" command that's useless for our purposes (antiquated KNR
-#	compiler or front-end that just hangs waiting for an answer from
-#	some licence manager).
+#    We try "gcc" first as commercial Unixen often have a bundled
+#    "cc" command that's useless for our purposes (antiquated KNR
+#    compiler or front-end that just hangs waiting for an answer from
+#    some licence manager).
 #
 printf "looking for a C compiler..."
 if [ -n "$CC" ]
@@ -253,11 +253,11 @@
       CC=cc
       if type $CC >/dev/null 2>&1
       then
-	:
+    :
       else
-	echo " none"
-	echo "error: none of (gcc, c89, cc) work, is your PATH set right?" 1>&2
-	exit 1
+    echo " none"
+    echo "error: none of (gcc, c89, cc) work, is your PATH set right?" 1>&2
+    exit 1
       fi
     fi
   fi
@@ -265,7 +265,7 @@
 echo " $CC"
 
 #
-#	Does the C compiler actually work ?
+#    Does the C compiler actually work ?
 #
 cdir=/tmp
 cbasename=${APPNAME}_$$.c
@@ -283,7 +283,7 @@
 fi
 
 #
-#	Do we have gettimeofday() ?
+#    Do we have gettimeofday() ?
 #
 check "for gettimeofday" HAVE_GETTIMEOFDAY '
 #include <sys/time.h>
@@ -298,7 +298,7 @@
 ' || true
 
 #
-#	Do we have nanosleep() ?
+#    Do we have nanosleep() ?
 #
 check "for nanosleep" HAVE_NANOSLEEP '
 #include <time.h>
@@ -313,7 +313,7 @@
 ' || true
 
 #
-#	Do we have snprintf() ?
+#    Do we have snprintf() ?
 #
 check "for snprintf" HAVE_SNPRINTF '
 #include <stdio.h>
@@ -326,7 +326,7 @@
 ' || true
 
 #
-#	Do we have usleep() ?
+#    Do we have usleep() ?
 #
 check "for usleep" HAVE_USLEEP '
 #include <unistd.h>
@@ -339,9 +339,9 @@
 ' || true
 
 #
-#	Look for a C++ compiler
+#    Look for a C++ compiler
 #
-#	We try "g++" first, then "c++", then "cxx".
+#    We try "g++" first, then "c++", then "cxx".
 #
 printf "looking for a C++ compiler..."
 if [ -n "$CXX" ]
@@ -361,11 +361,11 @@
       CXX=cxx
       if type $CXX >/dev/null 2>&1
       then
-	:
+    :
       else
-	echo " none"
-	echo "error: none of (g++, c++, cxx) work, is your PATH set right?" 1>&2
-	exit 1
+    echo " none"
+    echo "error: none of (g++, c++, cxx) work, is your PATH set right?" 1>&2
+    exit 1
       fi
     fi
   fi
@@ -373,7 +373,7 @@
 echo " $CXX"
 
 #
-#	Does the C++ compiler actually work ?
+#    Does the C++ compiler actually work ?
 #
 cdir=/tmp
 cbasename=${APPNAME}_$$.cc
@@ -391,7 +391,7 @@
 fi
 
 #
-#	Create the directory where the build-specific files go
+#    Create the directory where the build-specific files go
 #
 SYSTEM_RAW="`uname -n`_`uname -a | cksum`"
 SYSTEM="`echo "$SYSTEM_RAW" | tr -dc '[:alnum:]._-'`"
@@ -400,11 +400,11 @@
 mkdir -p $BUILDDIR
 
 #
-#	FHS paths
+#    FHS paths
 #
 if expr "$PREFIX" : '//*usr/*$' >/dev/null
 then
-  BINDIR=/usr/bin		# FHS-ly correct is /usr/games
+  BINDIR=/usr/bin        # FHS-ly correct is /usr/games
   ETCDIR=/etc/$APPNAME/%v
   ETCDIRNV=/etc/$APPNAME
   MANDIR=/usr/share/man
@@ -412,7 +412,7 @@
   SHAREDIRNV=/usr/share/games/$APPNAME
 elif expr "$PREFIX" : '//*usr//*local/*$' >/dev/null
 then
-  BINDIR=/usr/local/bin		# FHS-ly correct is /usr/local/games
+  BINDIR=/usr/local/bin        # FHS-ly correct is /usr/local/games
   ETCDIR=/etc/$APPNAME/%v
   ETCDIRNV=/etc/$APPNAME
   MANDIR=/usr/local/man
@@ -430,17 +430,23 @@
   MANDIR=$PREFIX/man
   SHAREDIR=$PREFIX/share
   SHAREDIRNV=
-else					# Probably /home/joe/*
-  BINDIR=$PREFIX/bin
-  ETCDIR=$PREFIX/etc
-  ETCDIRNV=
-  MANDIR=$PREFIX/man
-  SHAREDIR=$PREFIX/share
-  SHAREDIRNV=
+else                    # Probably /home/joe/*
+  #BINDIR=$PREFIX/bin
+  #ETCDIR=$PREFIX/etc
+  #ETCDIRNV=
+  #MANDIR=$PREFIX/man
+  #SHAREDIR=$PREFIX/share
+  #SHAREDIRNV=
+  BINDIR=$PREFIX/usr/games
+  ETCDIR=$PREFIX/etc/$APPNAME/%v
+  ETCDIRNV=$PREFIX/etc/$APPNAME
+  MANDIR=$PREFIX/usr/share/man
+  SHAREDIR=$PREFIX/usr/share/$APPNAME/%v
+  SHAREDIRNV=$PREFIX/usr/share/games/$APPNAME
 fi
 
 #
-#	Write Makefile.config
+#    Write Makefile.config
 #
 echo generating $BUILDDIR/Makefile.config
 (
@@ -451,6 +457,8 @@
   echo "CXX               = $CXX"
   echo "ETCDIR            = $ETCDIR" | sed "s/%v/$VERSION/g"
   echo "ETCDIRNV          = $ETCDIRNV"
+  #echo "ETCDIR            = /etc/$APPNAME/%v" | sed "s/%v/$VERSION/g"
+  #echo "ETCDIRNV          = /etc/$APPNAME"
   echo "HAVE_GETTIMEOFDAY = $HAVE_GETTIMEOFDAY"
   echo "HAVE_NANOSLEEP    = $HAVE_NANOSLEEP"
   echo "HAVE_SNPRINTF     = $HAVE_SNPRINTF"
@@ -463,33 +471,33 @@
 ) >$BUILDDIR/Makefile.config
 
 #
-#	YGD files search path
+#    YGD files search path
 #
 echo generating $BUILDDIR/config.share
 $GREP -Fvx '' <<EOF >"$BUILDDIR/config.share"
 .
 ~/.$APPNAME/%v
 ~/.$APPNAME
-$SHAREDIR
-$SHAREDIRNV
+/usr/share/$APPNAME/%v
+/usr/share/games/$APPNAME
 EOF
 
 #
-#	Config files search path
+#    Config files search path
 #
 echo generating $BUILDDIR/config.etc
 $GREP -Fvx '' <<EOF >"$BUILDDIR/config.etc"
 .
 ~/.$APPNAME/%v
 ~/.$APPNAME
-$ETCDIR
-$ETCDIRNV
+/etc/$APPNAME/%v
+/etc/$APPNAME
 EOF
 
 #
-#	Write config.h and config.cc
+#    Write config.h and config.cc
 #
-genc 
+genc
 genh
 
 exit 0
--- yadex-1.7.0.orig/GNUmakefile
+++ yadex-1.7.0/GNUmakefile
@@ -160,6 +160,7 @@
 	s_swapf		s_vertices	sanity		scrnshot	\
 	selbox		selectn		selpath		selrect		\
 	serialnum	spritdir	sticker		swapmem		\
+ 	r_render	r_images					\
 	t_centre	t_flags		t_prop		t_spin		\
 	textures	things		trace		v_centre	\
 	v_merge		v_polyg		vectext		verbmsg		\
@@ -237,6 +238,7 @@
 	docsrc/legal.html		\
 	docsrc/packagers_guide.html	\
 	docsrc/palette.html		\
+	docsrc/preview.html		\
 	docsrc/reporting.html		\
 	docsrc/tips.html		\
 	docsrc/trivia.html		\
@@ -381,7 +383,7 @@
 
 $(OBJDIR)/yadex: $(OBJ_CONFIG) $(OBJ_YADEX) $(OBJ_ATCLIB) $(MAKEFILE)
 	@echo "** Linking Yadex"
-	$(CXX) $(OBJ_CONFIG) $(OBJ_YADEX) $(OBJ_ATCLIB) -o $@		\
+	$(CXX) -m32 $(OBJ_CONFIG) $(OBJ_YADEX) $(OBJ_ATCLIB) -o $@		\
 	  -L$(X11LIBDIR) -lX11 -lm -lc $(LDFLAGS)
 
 .PHONY: test
@@ -609,8 +611,9 @@
 #
 ########################################################################
 
-# If Makefile.config doesn't exist, give a hint...
+# If Makefile.config or config.h don't exist, give a hint...
 $(OBJDIR)/Makefile.config:
+$(OBJDIR)/config.h:
 	@echo "Sorry guv'nor, but... did you run ./configure ?" >&2
 	@false
 
@@ -637,7 +640,7 @@
 # Note: the modules of Atclib are not scanned as they all
 # depend on $(HEADERS_ATCLIB) and nothing else.
 
-yadex.dep: $(SRC_NON_GEN)
+yadex.dep: $(SRC_NON_GEN) src/config.h
 	@echo "Generating $@"
 	@makedepend -f- -Y -Iatclib $(SRC_NON_GEN) 2>/dev/null	\
 		| awk 'sub (/^src/, "") == 1 {				\
@@ -730,18 +733,18 @@
 	cp -p $< $@
 
 $(OBJDIR)/%.o: src/%.cc
-	$(CXX) -c -Iatclib -Iboost -I$(X11INCLUDEDIR) $(CXXFLAGS) $< -o $@
+	$(CXX) -m32 -c -Iatclib -Iboost -I$(X11INCLUDEDIR) $(CXXFLAGS) $< -o $@
 
 $(DOBJDIR)/%.o: src/%.cc
-	$(CXX) -c -Iatclib -Iboost -I$(X11INCLUDEDIR) $(DCXXFLAGS) $< -o $@
+	$(CXX) -m32 -c -Iatclib -Iboost -I$(X11INCLUDEDIR) $(DCXXFLAGS) $< -o $@
 
 # To compile the modules of Atclib
 # (normal and debugging versions)
 $(OBJDIR_ATCLIB)/%.o: atclib/%.c $(HEADERS_ATCLIB)
-	$(CC) -c $(CFLAGS) $< -o $@
+	$(CC) -m32 -c $(CFLAGS) $< -o $@
 
 $(DOBJDIR_ATCLIB)/%.o: atclib/%.c $(HEADERS_ATCLIB)
-	$(CC) -c $(DCFLAGS) $< -o $@
+	$(CC) -m32 -c $(DCFLAGS) $< -o $@
 
 # To see the generated assembly code
 # for the modules of Yadex
@@ -875,7 +878,9 @@
 # The images are just symlinked from docsrc/ to doc/
 doc/%.png: docsrc/%.png
 	@rm -f $@
-	@ln -s ../$< $@
+#@ln -s ../$< $@
+# remove the -s ../ so the files get hardlinked correctly
+	@ln $< $@
 
 $(OBJDIR)/ftime: scripts/ftime.c
 	$(CC) $< -o $@
--- yadex-1.7.0.orig/atclib/al_adigits.c
+++ yadex-1.7.0/atclib/al_adigits.c
@@ -29,5 +29,11 @@
 #include "atclib.h"
 
 
-const char al_adigits[36] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+const char al_adigits[36] =
+{
+'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
+'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
+'U', 'V', 'W', 'X', 'Y', 'Z'
+};
 
--- yadex-1.7.0.orig/docsrc/index.html
+++ yadex-1.7.0/docsrc/index.html
@@ -34,6 +34,7 @@
 
 <ul>
 <li><a href="palette.html">Palette viewer</a>
+<li><a href="preview.html">3D Level Preview</a>
 <li><a href="advanced.html">Advanced user's guide</a>
 <li><a href="../TODO"><code>TODO</code></a>
 <li><a href="yadex.6">The man page for Yadex</a>
--- yadex-1.7.0.orig/docsrc/preview.html
+++ yadex-1.7.0/docsrc/preview.html
@@ -0,0 +1,108 @@
+<html>
+<head>
+<title>Yadex 3D level preview</title>
+</head>
+<body>
+
+<div align="center">
+<img src="logo_small.png" alt="Fancy logo">
+<br>Yadex $VERSION ($SOURCE_DATE)
+<h1>3D Level Preview</h1>
+</div>
+<br>
+<br>
+<br>
+
+	<h2>What's it for</h2>
+
+<p>The 3D level preview function lets you get a rough idea of what
+your level looks like, quickly, without all the hassle of saving,
+building nodes and starting DOOM. It is activated by pressing the
+`R' key while editing a level, and draws the player's view that
+you would see within DOOM (with some limitations). While the
+rendering window is up, you can move around the level using the
+cursor keys and toggle things like texturing and sprites on/off.
+
+	<h2>Key bindings</h2>
+
+<dl>
+<dt>[<kbd>Left</kbd>]
+<br>[<kbd>Right</kbd>]
+<dd>Turn the view left or right. Use the SHIFT key to
+turn a greater amount.
+
+<dt>[<kbd>Up</kbd>]
+<br>[<kbd>Down</kbd>]
+<dd>Move the view forward or back. Use the SHIFT key to
+move a greater distance.
+
+<dt>[<kbd>n</kbd>]
+<br>[<kbd>m</kbd>]
+<dd>Move the view sideways left or right (strafing). Uppercase `N'
+and `M' (i.e. with the SHIFT key) will move a greater distance.
+
+<dt>[<kbd>c</kbd>]
+<br>[<kbd>d</kbd>]
+<dd>Move the view upwards or downwards (flying). Uppercase `C' and
+`D' (i.e. with the SHIFT key) will move a greater distance. Note
+that you cannot move up or down when "walking" mode is enabled.
+
+<dt>[<kbd>t</kbd>]
+<dd>Toggle texture mapping. When disabled (the default), all walls,
+ceilings and floors are drawn with solid (somewhat random) colours.
+
+<dt>[<kbd>s</kbd>]
+<dd>Toggle sprites.
+
+<dt>[<kbd>w</kbd>]
+<dd>Toggle walking mode. When enabled, the view height is always
+above the current floor. For example, if you move forward over a
+cliff, the view will drop down.  When disabled (the default), you can
+fly about the level at any height.
+
+<dt>[<kbd>Esc</kbd>]
+<br>[<kbd>q</kbd>]
+<dd>Exit the 3D level preview. The current viewing state (position,
+direction, etc) are remembered, and will be used next time the 3D
+preview is activated (unless the player object has been moved, or a
+different level was loaded).
+
+</dl>
+
+	<h2>Features</h2>
+
+<ul>
+<li>No BSP (nodes) required !
+<li>Textures and flats are drawn exactly like DOOM, including X/Y
+offsets and upper/lower unpegging flags.
+<li>Sky is handled just like in DOOM (but drawn in solid blue).
+</ul>
+
+	<h2>Limitations</h2>
+
+<ul>
+<li>No lighting, the level appears full-bright all the time.
+<li>No mid-masked textures (rails, gratings) are drawn.
+<li>Thing sprites (especially monsters) are always drawn facing
+you, even when their direction is away from you.
+<li>Sprite positioning may be inaccurate, because their X and
+Y offsets are not honoured.
+<li>Things that are supposed to hang from the ceiling
+(hanging body parts, chandeliers, etc) will appear on the floor.
+<li>There are some glitches in the current renderer, which look like
+"slimetrails" (vertical lines).
+</ul>
+
+	<h2>Caveats</h2>
+
+One last thing. The 3D preview function can use a huge amount of
+memory when texturing and sprites are both enabled (and a large amount
+even when texturing and sprites are both disabled). If your computer
+has a very low amount of memory (e.g. less than 16 MB), then Yadex may
+crash with an out of memory error. I think you are unlikely to hit
+this problem, but if in doubt, save your work first.
+
+
+<p><hr>AJA $SELF_DATE
+</body>
+</html>
--- yadex-1.7.0.orig/src/editloop.cc
+++ yadex-1.7.0/src/editloop.cc
@@ -43,6 +43,7 @@
 #include "entry.h"
 #include "entry2.h"
 #include "events.h"
+#include "game.h"
 #include "gfx.h"
 #include "gfx2.h"	// show_character_set() show_pcolours()
 #include "gfx3.h"
@@ -70,6 +71,7 @@
 #include "x_exchng.h"
 #include "x_hover.h"
 #include "xref.h"
+#include "r_render.h"
 
 #ifdef Y_X11
 #include <X11/Xlib.h>
@@ -93,6 +95,7 @@
 
 /* prototypes of private functions */
 static int SortLevels (const void *item1, const void *item2);
+static char *GetBehaviorFileName (const char *levelname);
 
 /*
  *	SelectLevel
@@ -302,15 +305,27 @@
    "~Quit",       'q',   0,
    NULL);
 
-e.mb_menu[MBM_EDIT] = new Menu (NULL,
-   "~Copy object(s)",          'o',    0,
-   "~Add object",              YK_INS, 0,
-   "~Delete object(s)",        YK_DEL, 0,
-   "~Exchange object numbers", 24,     0,
-   "~Preferences...",          YK_F5,  0,
-   "~Snap to grid",            'y',    MIF_VTICK, &e.grid_snap,		     0,
-   "~Lock grid step",          'z',    MIF_VTICK, &e.grid_step_locked,	     0,
-   NULL);
+if (yg_level_format == YGLF_HEXEN)
+   e.mb_menu[MBM_EDIT] = new Menu (NULL,
+     "~Copy object(s)",          'o',    0,
+      "~Add object",              YK_INS, 0,
+      "~Delete object(s)",        YK_DEL, 0,
+      "~Exchange object numbers", 24,     0,
+      "~Preferences...",          YK_F5,  0,
+      "~Snap to grid",            'y',    MIF_VTICK, &e.grid_snap,        0,
+      "~Lock grid step",          'z',    MIF_VTICK, &e.grid_step_locked, 0,
+      "Load ~BEHAVIOR lump",      'b',    0,
+      NULL);
+else
+   e.mb_menu[MBM_EDIT] = new Menu (NULL,
+      "~Copy object(s)",          'o',    0,
+      "~Add object",              YK_INS, 0,
+      "~Delete object(s)",        YK_DEL, 0,
+      "~Exchange object numbers", 24,     0,
+      "~Preferences...",          YK_F5,  0,
+      "~Snap to grid",            'y',    MIF_VTICK, &e.grid_snap,        0,
+      "~Lock grid step",          'z',    MIF_VTICK, &e.grid_step_locked, 0,
+      NULL);
 
 // If you change the order of modes here, don't forget
 // to modify the <modes> array.
@@ -342,6 +357,7 @@
    "~Next object",       'n',   0,
    "~Prev object",       'p',   0,
    "~Jump to object...", 'j',   0,
+   "~Find by type",	 'f',	0,
    NULL);
 
 e.mb_menu[MBM_MISC_L] = new Menu ("Misc. operations",
@@ -1344,8 +1360,8 @@
             }
          }
 
-      // [F8]: pop up the "Misc. operations" menu
-      else if (is.key == YK_F8
+      // [M]: pop up the "Misc. operations" menu
+      else if (is.key == 'M'
          && e.menubar->highlighted () < 0)
          {
          e.modpopup->set (e.menubar->get_menu (MBI_MISC), 1);
@@ -1706,7 +1722,15 @@
 	 select_linedefs_path (&e.Selected, e.highlighted.num, YS_TOGGLE);
 	 RedrawMap = 1;
 	 }
-
+      // [E]: add linedef and split sector -- [AJA]
+      else if (is.key == 'E' && e.obj_type == OBJ_VERTICES)
+        {
+        if (e.Selected)
+          {
+          MiscOperations (e.obj_type, &e.Selected, 5);
+          RedrawMap = 1;
+          }
+        }
       // [E]: Select/unselect all 1s linedefs in path
       else if (is.key == 'E' && e.highlighted._is_linedef ())
 	 {
@@ -1834,6 +1858,56 @@
 	 RedrawMap = 1;
 	 }
 
+      // [f]: find object by type
+      else if (is.key == 'f' && (! e.global || e.highlighted ())) 
+	 {
+	 Objid find_obj;
+	 int otype;
+	 obj_no_t omax,onum;
+	 find_obj.type = e.highlighted () ? e.highlighted.type : e.obj_type;
+	 onum = find_obj.num  = e.highlighted () ? e.highlighted.num  : 0;
+	 omax = GetMaxObjectNum(find_obj.type);
+         switch (find_obj.type)
+            {
+	    case OBJ_SECTORS:
+               if ( ! InputSectorType( 84, 21, &otype))
+		  {
+	          for (onum = e.highlighted () ? onum + 1 : onum; onum <= omax; onum++)
+	             if (Sectors[onum].special == (wad_stype_t) otype)
+			{
+		        find_obj.num = onum;
+	                GoToObject(find_obj);
+		        break;
+		        }
+		  }
+	    break;
+	    case OBJ_THINGS:
+	       if ( ! InputThingType( 42, 21, &otype))
+	 	  {
+                  for (onum = e.highlighted () ? onum + 1 : onum; onum <= omax; onum++)
+	             if (Things[onum].type == (wad_ttype_t) otype)
+                        {
+		        find_obj.num = onum;
+	                GoToObject(find_obj);
+		        break;
+		        }
+		  }
+	    break;
+	    case OBJ_LINEDEFS:
+	       if ( ! InputLinedefType( 0, 21, &otype))
+		  {
+	          for (onum = e.highlighted () ? onum + 1 : onum; onum <= omax; onum++)
+		     if (LineDefs[onum].type == (wad_ldtype_t) otype)
+			{
+		        find_obj.num = onum;
+	                GoToObject(find_obj);
+			break;
+		        }
+		  }
+	    break;
+	    }
+         RedrawMap = 1;
+         }
 #if 0
       // [c]: clear selection and redraw the map
       else if (is.key == 'c')
@@ -1921,6 +1995,17 @@
          StretchSelBox = false;
          }
 
+      // [w]: split sector between vertices
+      else if (is.key == 'w' && e.obj_type == OBJ_VERTICES
+         && e.Selected && e.Selected->next && ! e.Selected->next->next)
+         {
+         SplitSector (e.Selected->next->objnum, e.Selected->objnum);
+         ForgetSelection (&e.Selected);
+         RedrawMap = 1;
+         DragObject = false;
+         StretchSelBox = false;
+         }
+
       // [x]: spin things 1/8 turn clockwise
       else if (is.key == 'x' && e.obj_type == OBJ_THINGS
          && (e.Selected || e.highlighted ()))
@@ -1987,7 +2072,7 @@
       }
       
       // [Del]: delete the current object
-      else if (is.key == YK_DEL
+      else if (is.key == '\b'
          && (e.Selected || e.highlighted ())) /* 'Del' */
 	 {
 	 if (e.obj_type == OBJ_THINGS
@@ -2015,7 +2100,7 @@
 	 }
 
       // [Ins]: insert a new object
-      else if (is.key == YK_INS || is.key == YK_INS + YK_SHIFT) /* 'Ins' */
+      else if (is.key == 'I' || is.key == YK_INS + YK_SHIFT) /* 'Ins' */
 	 {
 	 SelPtr cur;
          int prev_obj_type = e.obj_type;
@@ -2201,12 +2286,34 @@
 	 RedrawMap = 1;
 	 }
 
+      // [Z] Set sector on surrounding linedefs (AJA)
+      else if (is.key == 'Z' && e.pointer_in_window) 
+         {
+         if (e.obj_type == OBJ_SECTORS && e.Selected)
+            {
+            SuperSectorSelector (e.pointer_x, e.pointer_y,
+               e.Selected->objnum);
+            }
+         else
+            {
+            SuperSectorSelector (e.pointer_x, e.pointer_y, OBJ_NO_NONE);
+            }
+         RedrawMap = 1;
+         }
+
       // [!] Debug info (not documented)
       else if (is.key == '!')
          {
          DumpSelection (e.Selected);
          }
 
+      // [R] Render 3D view (AJA)
+      else if (is.key == 'R')
+        {
+        Render3D ();
+        RedrawMap = 1;
+        }
+
       // [@] Show font (not documented)
       else if (is.key == '@')
          {
@@ -2214,6 +2321,30 @@
 	 RedrawMap = 1;
          }
 
+      // [T] Transfer properties to selected objects (AJA)
+      else if (is.key == 'T' && e.Selected 
+            && e.highlighted.num >= 0)
+         {
+         switch (e.obj_type)
+            {
+            case OBJ_SECTORS:
+               TransferSectorProperties (e.highlighted.num, e.Selected);
+               RedrawMap = 1;
+               break;
+            case OBJ_THINGS:
+               TransferThingProperties (e.highlighted.num, e.Selected);
+               RedrawMap = 1;
+               break;
+            case OBJ_LINEDEFS:
+               TransferLinedefProperties (e.highlighted.num, e.Selected);
+               RedrawMap = 1;
+               break;
+            default:
+               Beep ();
+               break;
+            }
+         }
+
       // [|] Show colours (not documented)
       else if (is.key == '|')
          {
@@ -2298,6 +2429,30 @@
 	 RedrawMap = 1;
 	 }
 
+      // Load BEHAVIOR lump (JL)
+      else if (is.key == 'b')
+         {
+         char *acsfile;
+         const char *acsname;
+         if (levelname)
+            acsname = levelname;
+         else
+            acsname = "behavior";
+         acsfile = GetBehaviorFileName (acsname);
+         FILE* f = fopen(acsfile, "rb");
+         if (f)
+            {
+            FreeFarMemory(Behavior);
+            fseek(f, 0, SEEK_END);
+            BehaviorSize = ftell(f);
+            Behavior = (u8*)GetFarMemory(BehaviorSize);
+            fseek(f, 0, SEEK_SET);
+            fread(Behavior, BehaviorSize, 1, f);
+            fclose(f);
+            }
+         RedrawMap = 1;
+      }
+
       /* user likes music */
       else if (is.key)
 	 {
@@ -2448,3 +2603,30 @@
 }
 
 
+/*
+   get the name of the BEHAVIOR lump file (returns NULL on Esc)
+*/
+
+static char *GetBehaviorFileName (const char *levelname)
+{
+#define BUFSZ 79
+  char *outfile = (char *) GetMemory (BUFSZ + 1);
+
+  /* get the file name */
+  // If no name, find a default one
+  if (! levelname)
+  {
+    levelname = "behavior";
+  }
+  al_scpslower (outfile, levelname, BUFSZ);
+  al_saps (outfile, ".o", BUFSZ);
+  InputFileName (-1, -1, "Name of the BEHAVIOR script file:", BUFSZ, outfile);
+  /* escape */
+  if (outfile[0] == '\0')
+  {
+    FreeMemory (outfile);
+    return 0;
+  }
+  return outfile;
+ }
+
--- yadex-1.7.0.orig/src/editloop.h
+++ yadex-1.7.0/src/editloop.h
@@ -6,6 +6,9 @@
 
 void EditorLoop (const char *); /* SWAP! */
 const char *SelectLevel (int levelno);
+extern int InputSectorType(int x0, int y0, int *number);
+extern int InputLinedefType(int x0, int y0, int *number);
+extern int InputThingType(int x0, int y0, int *number);
 
 
 
--- yadex-1.7.0.orig/src/gcolour1.cc
+++ yadex-1.7.0/src/gcolour1.cc
@@ -127,6 +127,21 @@
   }
   verbmsg ("colours: colour %d remapped to %d (delta %d)\n",
     IMG_TRANSP, colour0, smallest_delta);
+   
+   rgb_c med_blue (0, 0, 128);
+   sky_colour = 0;
+   smallest_delta = INT_MAX;
+ 
+   for (size_t n = 0; n < DOOM_COLOURS; n++)
+   {
+     int delta = med_blue - rgb_values[n];
+     if (delta < smallest_delta)
+     {
+       sky_colour = n;
+       smallest_delta = delta;
+     }
+   }
+   verbmsg ("Sky Colour remapped to %d (delta %d)\n", sky_colour, smallest_delta);
 }
 
 #endif
--- yadex-1.7.0.orig/src/gcolour2.cc
+++ yadex-1.7.0/src/gcolour2.cc
@@ -35,4 +35,5 @@
 
 pcolour_t *game_colour = 0;	// Pixel values for the DOOM_COLOURS game clrs.
 int colour0;			// Game colour to which g. colour 0 is remapped
+int sky_colour;			// Game colour for a medium sky blue
 
--- yadex-1.7.0.orig/src/gcolour2.h
+++ yadex-1.7.0/src/gcolour2.h
@@ -10,4 +10,5 @@
 
 extern pcolour_t *game_colour;  // Pixel values for the DOOM_COLOURS game clrs.
 extern int colour0;		// Game colour to which g. colour 0 is remapped
+extern int sky_colour;		// Game colour for a medium blue sky
 
--- yadex-1.7.0.orig/src/gfx.cc
+++ yadex-1.7.0/src/gfx.cc
@@ -310,7 +310,7 @@
     win_vis_id    = vis_info->visualid;
 #if defined _cplusplus || defined __cplusplus
     win_vis_class = vis_info->c_class;
-#elif
+#else
     win_vis_class = vis_info->class;
 #endif
     win_ncolours  = vis_info->colormap_size;
--- yadex-1.7.0.orig/src/l_prop.cc
+++ yadex-1.7.0/src/l_prop.cc
@@ -105,13 +105,13 @@
  *	Prototypes of private functions
  */
 static char *GetTaggedLineDefFlag (int linedefnum, int flagndx);
-static int InputLinedefType (int x0, int y0, int *number);
+int InputLinedefType (int x0, int y0, int *number);
 static const char *PrintLdtgroup (void *ptr);
 
 
 void LinedefProperties (int x0, int y0, SelPtr obj)
 {
-  char  *menustr[8];
+  char  *menustr[12];
   char   texname[WAD_TEX_NAME + 1];
   int    n, val;
   SelPtr cur, sdlist;
@@ -132,9 +132,9 @@
   switch (val)
   {
     case 1:
-      for (n = 0; n < 8; n++)
+      for (n = 0; n < 12; n++)
 	menustr[n] = (char *) GetMemory (60);
-      sprintf (menustr[7], "Edit linedef #%d", obj->objnum);
+      sprintf (menustr[11], "Edit linedef #%d", obj->objnum);
       sprintf (menustr[0], "Change flags            (Current: %d)",
 	LineDefs[obj->objnum].flags);
       sprintf (menustr[1], "Change type             (Current: %d)",
@@ -149,7 +149,16 @@
 	LineDefs[obj->objnum].sidedef1);
       sprintf (menustr[6], "Change 2nd sidedef ref. (Current: #%d)",
 	LineDefs[obj->objnum].sidedef2);
-      val = vDisplayMenu (x0 + 42, subwin_y0, menustr[7],
+      sprintf (menustr[7], "Change special arg2     (Current: %d)",
+    LineDefs[obj->objnum].arg2);
+      sprintf (menustr[8], "Change special arg3     (Current: %d)",
+    LineDefs[obj->objnum].arg3);
+      sprintf (menustr[9], "Change special arg4     (Current: %d)",
+    LineDefs[obj->objnum].arg4);
+      sprintf (menustr[10], "Change special arg5     (Current: %d)",
+    LineDefs[obj->objnum].arg5);
+      if (yg_level_format == YGLF_HEXEN)
+         val = vDisplayMenu (x0 + 42, subwin_y0, menustr[11],
 	menustr[0], YK_, 0,
 	menustr[1], YK_, 0,
 	menustr[2], YK_, 0,
@@ -157,8 +166,22 @@
 	menustr[4], YK_, 0,
 	menustr[5], YK_, 0,
 	menustr[6], YK_, 0,
-	NULL);
-      for (n = 0; n < 8; n++)
+   menustr[7], YK_, 0,
+   menustr[8], YK_, 0,
+   menustr[9], YK_, 0,
+   menustr[10], YK_, 0,
+    NULL);
+     else
+         val = vDisplayMenu (x0 + 42, subwin_y0, menustr[11],
+   menustr[0], YK_, 0,
+   menustr[1], YK_, 0,
+   menustr[2], YK_, 0,
+   menustr[3], YK_, 0,
+   menustr[4], YK_, 0,
+   menustr[5], YK_, 0,
+   menustr[6], YK_, 0,
+   NULL);
+      for (n = 0; n < 12; n++)
 	FreeMemory (menustr[n]);
       subsubwin_y0 = subwin_y0 + BOX_BORDER + (2 + val) * FONTH;
       switch (val)
@@ -267,9 +290,51 @@
 	      LineDefs[cur->objnum].sidedef2 = val;
 	    MadeChanges = 1;
 	    MadeMapChanges = 1;
+     }
+     break;
+
+   case 8:
+     val = InputIntegerValue (x0 + 84, subsubwin_y0,
+       0, 255, LineDefs[obj->objnum].arg2);
+     if (val != IIV_CANCEL)  // Not [esc]
+     {
+       for (cur = obj; cur; cur = cur->next)
+         LineDefs[cur->objnum].arg2 = val;
+       MadeChanges = 1;
+     }
+     break;
+   case 9:
+     val = InputIntegerValue (x0 + 84, subsubwin_y0,
+       0, 255, LineDefs[obj->objnum].arg3);
+     if (val != IIV_CANCEL)  // Not [esc]
+     {
+       for (cur = obj; cur; cur = cur->next)
+         LineDefs[cur->objnum].arg3 = val;
+       MadeChanges = 1;
+     }
+     break;
+
+   case 10:
+     val = InputIntegerValue (x0 + 84, subsubwin_y0,
+       0, 255, LineDefs[obj->objnum].arg4);
+     if (val != IIV_CANCEL)  // Not [esc]
+     {
+       for (cur = obj; cur; cur = cur->next)
+         LineDefs[cur->objnum].arg4 = val;
+       MadeChanges = 1;
+     }
+     break;
+   case 11:
+     val = InputIntegerValue (x0 + 84, subsubwin_y0,
+       0, 255, LineDefs[obj->objnum].arg5);
+     if (val != IIV_CANCEL)  // Not [esc]
+     {
+       for (cur = obj; cur; cur = cur->next)
+         LineDefs[cur->objnum].arg5 = val;
+       MadeChanges = 1;
 	  }
 	  break;
-     }
+     } // switch (val)
      break;
 
     // Edit or add the first sidedef
@@ -475,7 +540,7 @@
  *	Let the user select a linedef type number and return it.
  *	Returns 0 if OK, <>0 if cancelled
  */
-static int InputLinedefType (int x0, int y0, int *number)
+int InputLinedefType (int x0, int y0, int *number)
 {
   int         r;
   int         ldtgno = 0;
@@ -547,3 +612,37 @@
   return ((ldtgroup_t *)ptr)->desc;
 }
 
+/*
+ *   TransferLinedefProperties
+ *
+ *   Note: right now nothing is done about sidedefs.  Being able to
+ *   (intelligently) transfer sidedef properties from source line to
+ *   destination linedefs could be a useful feature -- though it is
+ *   unclear the best way to do it.  OTOH not touching sidedefs might
+ *   be useful too.
+ *
+ *   -AJA- 2001-05-27
+ */
+#define LINEDEF_FLAG_KEEP  (1 + 4)
+
+void TransferLinedefProperties (int src_linedef, SelPtr linedefs)
+{
+   SelPtr cur;
+   wad_ldflags_t src_flags = LineDefs[src_linedef].flags & ~LINEDEF_FLAG_KEEP;
+
+   for (cur=linedefs; cur; cur=cur->next)
+   {
+      if (! is_obj(cur->objnum))
+         continue;
+
+      // don't transfer certain flags
+      LineDefs[cur->objnum].flags &= LINEDEF_FLAG_KEEP;
+      LineDefs[cur->objnum].flags |= src_flags;
+
+      LineDefs[cur->objnum].type = LineDefs[src_linedef].type;
+      LineDefs[cur->objnum].tag  = LineDefs[src_linedef].tag;
+
+      MadeChanges = 1;
+   }
+}
+
--- yadex-1.7.0.orig/src/levels.cc
+++ yadex-1.7.0/src/levels.cc
@@ -58,6 +58,8 @@
 VPtr Vertices;			/* vertex data */
 int NumSectors;			/* number of sectors */
 SPtr Sectors;			/* sectors data */
+u8* Behavior;
+int BehaviorSize;
 
 // FIXME should be somewhere else
 int NumWTexture;		/* number of wall textures */
@@ -95,6 +97,10 @@
 				   the Level has never been saved yet,
 				   an empty string. */
 
+static u8 DefaultBehavior[16] = {
+    'A', 'C', 'S', 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
 void EmptyLevelData (const char *levelname)
 {
 Things = 0;
@@ -109,6 +115,13 @@
 NumSectors = 0;
 Vertices = 0;
 NumVertices = 0;
+if (yg_level_format == YGLF_HEXEN)
+   {
+    BehaviorSize = sizeof(DefaultBehavior);
+    Behavior = (u8*) GetFarMemory ((unsigned long) BehaviorSize );
+    memcpy(Behavior, DefaultBehavior, BehaviorSize);
+    }
+
 }
 
 
@@ -199,7 +212,7 @@
    {
    offset = dir->dir.start;
    length = dir->dir.size;
-   if (MainWad == Iwad4)  // Hexen mode
+   if (yg_level_format == YGLF_HEXEN)  // Hexen mode
       {
       NumThings = (int) (length / WAD_HEXEN_THING_BYTES);
       if ((i32) (NumThings * WAD_HEXEN_THING_BYTES) != length)
@@ -234,18 +247,23 @@
       rc = 1;
       goto byebye;
       }
-   if (MainWad == Iwad4)		// Hexen mode
+   if (yg_level_format == YGLF_HEXEN)		// Hexen mode
       for (long n = 0; n < NumThings; n++)
 	 {
          u8 dummy2[6];
-	 wf->read_i16   ();					// Tid
+     wf->read_i16   (&Things[n].tid  );
 	 wf->read_i16   (&Things[n].xpos );
 	 wf->read_i16   (&Things[n].ypos );
-	 wf->read_i16   ();					// Height
+     wf->read_i16   (&Things[n].height);
 	 wf->read_i16   (&Things[n].angle);
 	 wf->read_i16   (&Things[n].type );
 	 wf->read_i16   (&Things[n].when );
-         wf->read_bytes (dummy2, sizeof dummy2);
+     wf->read_u8    (Things[n].special);
+     wf->read_u8    (Things[n].arg1  );
+     wf->read_u8    (Things[n].arg2  );
+     wf->read_u8    (Things[n].arg3  );
+     wf->read_u8    (Things[n].arg4  );
+     wf->read_u8    (Things[n].arg5  );
 	 if (wf->error ())
 	    {
 	    err ("%s: error reading thing #%ld", lump_name, n);
@@ -283,7 +301,7 @@
       NumLineDefs = 0;
    else
       {
-      if (MainWad == Iwad4)  // Hexen mode
+      if (yg_level_format == YGLF_HEXEN)  // Hexen mode
 	 {
 	 NumLineDefs = (int) (dir->dir.size / WAD_HEXEN_LINEDEF_BYTES);
 	 if ((i32) (NumLineDefs * WAD_HEXEN_LINEDEF_BYTES) != dir->dir.size)
@@ -310,7 +328,7 @@
 	 rc = 1;
 	 goto byebye;
 	 }
-      if (MainWad == Iwad4)  // Hexen mode
+      if (yg_level_format == YGLF_HEXEN)  // Hexen mode
 	 for (long n = 0; n < NumLineDefs; n++)
 	    {
 	    u8 dummy[6];
@@ -322,6 +340,10 @@
 	    wf->read_i16   (&LineDefs[n].sidedef2);
 	    LineDefs[n].type = dummy[0];
 	    LineDefs[n].tag  = dummy[1];  // arg1 often contains a tag
+        LineDefs[n].arg2 = dummy[2];
+        LineDefs[n].arg3 = dummy[3];
+        LineDefs[n].arg4 = dummy[4];
+        LineDefs[n].arg5 = dummy[5];
 	    if (wf->error ())
 	       {
 	       err ("%s: error reading linedef #%ld", lump_name, n);
@@ -907,6 +929,37 @@
    }
 }
 
+// Read BEHAVIOR
+if (yg_level_format == YGLF_HEXEN)
+{
+const char *lump_name = "BEHAVIOR";
+verbmsg (" behavior\n");
+dir = FindMasterDir (Level, lump_name);
+if (dir)
+   {
+   BehaviorSize = (int)dir->dir.size;
+   if (BehaviorSize > 0)
+      {
+      Behavior = (u8*) GetFarMemory ((unsigned long) BehaviorSize );
+      const Wad_file *wf = dir->wadfile;
+      wf->seek (dir->dir.start);
+      if (wf->error ())
+         {
+         err ("%s: seek error", lump_name);
+         rc = 1;
+         goto byebye;
+         }
+      wf->read_bytes (Behavior, BehaviorSize);
+      if (wf->error ())
+         {
+         err ("%s: error behavior lump", lump_name);
+         rc = 1;
+         goto byebye;
+         }
+      }
+   }
+}
+
 /* Sanity checking on sidedefs: the sector must exist. I don't
    make this a fatal error, though, because it's not exceptional
    to find wads with unused sidedefs with a sector# of -1. Well
@@ -1011,16 +1064,10 @@
 FILE   *file;
 MDirPtr dir;
 int     n;
-long	lump_offset[WAD_LL__];
-size_t	lump_size[WAD_LL__];
+long	lump_offset[WAD_LL__MAX];
+size_t	lump_size[WAD_LL__MAX];
 wad_level_lump_no_t l;
 
-if (yg_level_format == YGLF_HEXEN || ! strcmp (Game, "hexen"))
-   {
-   Notify (-1, -1, "I refuse to save. Hexen mode is still",
-                   "too badly broken. You would lose data.");
-   return 1;
-   }
 if (! level_name || ! levelname2levelno (level_name))
    {
    nf_bug ("SaveLevelData: bad level_name \"%s\", using \"E1M1\" instead.",
@@ -1047,9 +1094,15 @@
   && ! MadeMapChanges
   && yg_level_format != YGLF_ALPHA;
 
+int NumLumps;
+if (yg_level_format == YGLF_HEXEN)
+   NumLumps = WAD_LL__HEXEN;
+else
+   NumLumps = WAD_LL__DOOM;
+
 // Write the pwad header
 WriteBytes (file, "PWAD", 4);		// Pwad file
-file_write_i32 (file, WAD_LL__);	// Number of entries = 11
+file_write_i32 (file, NumLumps);	// Number of entries = 11
 file_write_i32 (file, 0);		// Fix this up later
 if (Level)
    dir = Level->next;
@@ -1067,11 +1120,30 @@
 ObjectsNeeded (OBJ_THINGS, 0);
 for (n = 0; n < NumThings; n++)
    {
-   file_write_i16 (file, Things[n].xpos );
-   file_write_i16 (file, Things[n].ypos );
-   file_write_i16 (file, Things[n].angle);
-   file_write_i16 (file, Things[n].type );
-   file_write_i16 (file, Things[n].when );
+   if (yg_level_format == YGLF_HEXEN)
+      {
+      file_write_i16 (file, Things[n].tid  );
+      file_write_i16 (file, Things[n].xpos );
+      file_write_i16 (file, Things[n].ypos );
+      file_write_i16 (file, Things[n].height);
+      file_write_i16 (file, Things[n].angle);
+      file_write_i16 (file, Things[n].type );
+      file_write_i16 (file, Things[n].when );
+      WriteBytes     (file, &Things[n].special, 1);
+      WriteBytes     (file, &Things[n].arg1, 1 );
+      WriteBytes     (file, &Things[n].arg2, 1 );
+      WriteBytes     (file, &Things[n].arg3, 1 );
+      WriteBytes     (file, &Things[n].arg4, 1 );
+      WriteBytes     (file, &Things[n].arg5, 1 );
+     }
+   else
+      {
+      file_write_i16 (file, Things[n].xpos );
+      file_write_i16 (file, Things[n].ypos );
+      file_write_i16 (file, Things[n].angle);
+      file_write_i16 (file, Things[n].type );
+      file_write_i16 (file, Things[n].when );
+      }
    }
 lump_size[l] = ftell (file) - lump_offset[l];
 if (Level)
@@ -1083,13 +1155,32 @@
 ObjectsNeeded (OBJ_LINEDEFS, 0);
 for (n = 0; n < NumLineDefs; n++)
    {
-   file_write_i16 (file, LineDefs[n].start   );
-   file_write_i16 (file, LineDefs[n].end     );
-   file_write_i16 (file, LineDefs[n].flags   );
-   file_write_i16 (file, LineDefs[n].type    );
-   file_write_i16 (file, LineDefs[n].tag     );
-   file_write_i16 (file, LineDefs[n].sidedef1);
-   file_write_i16 (file, LineDefs[n].sidedef2);
+   if (yg_level_format == YGLF_HEXEN)
+      {
+      u8 dummy[6];
+      dummy[0] = LineDefs[n].type;
+      dummy[1] = LineDefs[n].tag;
+      dummy[2] = LineDefs[n].arg2;
+      dummy[3] = LineDefs[n].arg3;
+      dummy[4] = LineDefs[n].arg4;
+      dummy[5] = LineDefs[n].arg5;
+      file_write_i16 (file, LineDefs[n].start   );
+      file_write_i16 (file, LineDefs[n].end     );
+      file_write_i16 (file, LineDefs[n].flags   );
+      WriteBytes     (file, dummy, 6);
+      file_write_i16 (file, LineDefs[n].sidedef1);
+      file_write_i16 (file, LineDefs[n].sidedef2);
+     }
+   else
+      {
+      file_write_i16 (file, LineDefs[n].start   );
+      file_write_i16 (file, LineDefs[n].end     );
+      file_write_i16 (file, LineDefs[n].flags   );
+      file_write_i16 (file, LineDefs[n].type    );
+      file_write_i16 (file, LineDefs[n].tag     );
+      file_write_i16 (file, LineDefs[n].sidedef1);
+      file_write_i16 (file, LineDefs[n].sidedef2);
+     }
    }
 lump_size[l] = ftell (file) - lump_offset[l];
 if (Level)
@@ -1221,9 +1312,20 @@
 if (Level)
    dir = dir->next;
 
+// Write the BEHAVIOR lump
+if (yg_level_format == YGLF_HEXEN)
+{
+   l = WAD_LL_BEHAVIOR;
+   lump_offset[l] = ftell (file);
+   WriteBytes(file, Behavior, BehaviorSize);
+   lump_size[l] = BehaviorSize;
+   if (Level)
+      dir = dir->next;
+}
+
 // Write the actual directory
 long dir_offset = ftell (file);
-for (int L = 0; L < (int) WAD_LL__; L++)
+for (int L = 0; L < (int) NumLumps; L++)
    {
    file_write_i32 (file, lump_offset[L]);
    file_write_i32 (file, lump_size[L]);
--- yadex-1.7.0.orig/src/levels.h
+++ yadex-1.7.0/src/levels.h
@@ -28,6 +28,8 @@
 extern int   NumSegs;		/* number of segments */
 extern int   NumSectors;	/* number of sectors */
 extern SPtr  Sectors;		/* sectors data */
+extern u8*   Behavior;
+extern int   BehaviorSize;
 
 // FIXME should be somewhere else
 extern int   NumWTexture;	/* number of wall textures */
--- yadex-1.7.0.orig/src/objects.cc
+++ yadex-1.7.0/src/objects.cc
@@ -465,12 +465,28 @@
 	 Things[last].type  = Things[copyfrom].type;
 	 Things[last].angle = Things[copyfrom].angle;
 	 Things[last].when  = Things[copyfrom].when;
+     Things[last].tid   = Things[copyfrom].tid;
+     Things[last].height = Things[copyfrom].height;
+     Things[last].special = Things[copyfrom].special;
+     Things[last].arg1  = Things[copyfrom].arg1;
+     Things[last].arg2  = Things[copyfrom].arg2;
+     Things[last].arg3  = Things[copyfrom].arg3;
+     Things[last].arg4  = Things[copyfrom].arg4;
+     Things[last].arg5  = Things[copyfrom].arg5;
 	 }
       else
 	 {
 	 Things[last].type = default_thing;
 	 Things[last].angle = 0;
 	 Things[last].when  = 0x07;
+     Things[last].tid   = 0;
+     Things[last].height = 0;
+     Things[last].special = 0;
+     Things[last].arg1  = 0;
+     Things[last].arg2  = 0;
+     Things[last].arg3  = 0;
+     Things[last].arg4  = 0;
+     Things[last].arg5  = 0;
 	 }
       break;
 
@@ -508,6 +524,10 @@
 	 LineDefs[last].flags = LineDefs[copyfrom].flags;
 	 LineDefs[last].type  = LineDefs[copyfrom].type;
 	 LineDefs[last].tag   = LineDefs[copyfrom].tag;
+     LineDefs[last].arg2  = LineDefs[copyfrom].arg2;
+     LineDefs[last].arg3  = LineDefs[copyfrom].arg3;
+     LineDefs[last].arg4  = LineDefs[copyfrom].arg4;
+     LineDefs[last].arg5  = LineDefs[copyfrom].arg5;
 	 }
       else
 	 {
@@ -516,6 +536,10 @@
 	 LineDefs[last].flags = 1;
 	 LineDefs[last].type  = 0;
 	 LineDefs[last].tag   = 0;
+     LineDefs[last].arg2  = 0;
+     LineDefs[last].arg3  = 0;
+     LineDefs[last].arg4  = 0;
+     LineDefs[last].arg5  = 0;
 	 }
       LineDefs[last].sidedef1 = OBJ_NO_NONE;
       LineDefs[last].sidedef2 = OBJ_NO_NONE;
--- yadex-1.7.0.orig/src/s_misc.cc
+++ yadex-1.7.0/src/s_misc.cc
@@ -29,11 +29,15 @@
 
 
 #include "yadex.h"
+#include <math.h>
+
 #include "entry.h"
 #include "gfx.h"
 #include "levels.h"
 #include "objid.h"
 #include "selectn.h"
+#include "objects.h"
+#include "dialog.h"
 
 
 /*
@@ -179,4 +183,340 @@
 MadeChanges = 1;
 }
 
+
+static int find_linedef_for_area (int x, int y, int& side)
+{
+   int n, m, curx;
+   int best_match = -1;
+
+   curx = 32767;  // Oh yes, one more hard-coded constant!
+
+   for (n = 0; n < NumLineDefs; n++)
+      if ((Vertices[LineDefs[n].start].y > y)
+       != (Vertices[LineDefs[n].end].y > y))
+      {
+         int lx0 = Vertices[LineDefs[n].start].x;
+         int ly0 = Vertices[LineDefs[n].start].y;
+         int lx1 = Vertices[LineDefs[n].end].x;
+         int ly1 = Vertices[LineDefs[n].end].y;
+         m = lx0 + (int) ((long) (y - ly0) * (long) (lx1 - lx0)
+                                           / (long) (ly1 - ly0));
+         if (m >= x && m < curx)
+         {
+            curx = m;
+            best_match = n;
+         }
+      }
+
+   /* now look if this linedef has a sidedef bound to one sector */
+   if (best_match < 0)
+      return OBJ_NO_NONE;
+
+   if (Vertices[LineDefs[best_match].start].y
+     > Vertices[LineDefs[best_match].end].y)
+      side = 1;
+   else
+      side = 2;
+
+   return best_match;
+}
+
+/*
+   compute the angle between lines AB and BC, going anticlockwise.
+   result is in degrees 0 - 359.  A, B and C are vertex indices.
+   -AJA- 2001-05-09
+ */
+#define DEBUG_ANGLE  0
+
+static double angle_between_linedefs (int A, int B, int C)
+{
+   int a_dx = Vertices[B].x - Vertices[A].x;
+   int a_dy = Vertices[B].y - Vertices[A].y;
+   
+   int c_dx = Vertices[B].x - Vertices[C].x;
+   int c_dy = Vertices[B].y - Vertices[C].y;
+   
+   double AB_angle = (a_dx == 0) ? (a_dy >= 0 ? 90 : -90) :
+      atan2 (a_dy, a_dx) * 180 / M_PI;
+
+   double CB_angle = (c_dx == 0) ? (c_dy >= 0 ? 90 : -90) :
+      atan2 (c_dy, c_dx) * 180 / M_PI;
+
+   double result = CB_angle - AB_angle;
+
+   if (result >= 360)
+      result -= 360;
+   
+   while (result < 0)
+      result += 360;
+
+#if (DEBUG_ANGLE)
+   fprintf(stderr, "ANGLE %1.6f  (%d,%d) -> (%d,%d) -> (%d,%d)\n",
+      result, Vertices[A].x, Vertices[A].y,
+      Vertices[B].x, Vertices[B].y, Vertices[C].x, Vertices[C].y);
+#endif
+
+   return result;
+}
+
+/*
+   follows the path clockwise from the given start line, adding each
+   line into the appropriate set.  If the path is not closed, zero is
+   returned.  
+   
+   -AJA- 2001-05-09
+ */
+#define DEBUG_PATH  0
+
+static int select_sides_in_closed_path (bitvec_c& ld_side1,
+    bitvec_c& ld_side2, int line, int side)
+{
+   int cur_vert, prev_vert, final_vert;
+   
+   if (side == 1)
+   {
+      ld_side1.set (line);
+      cur_vert = LineDefs[line].end;
+      prev_vert = final_vert = LineDefs[line].start;
+   }
+   else
+   {
+      ld_side2.set (line);
+      cur_vert = LineDefs[line].start;
+      prev_vert = final_vert = LineDefs[line].end;
+   }
+
+#if (DEBUG_PATH)
+      fprintf(stderr, "PATH: line %d  side %d  cur %d  final %d\n",
+         line, side, cur_vert, final_vert);
+#endif
+
+   while (cur_vert != final_vert)
+   {
+      int next_line = OBJ_NO_NONE;
+      int next_vert = OBJ_NO_NONE;
+      int next_side;
+      double best_angle = 999;
+
+      // Look for the next linedef in the path.  It's the linedef that
+      // uses the current vertex and is not the current one.
+
+      for (int n = 0; n < NumLineDefs; n++)
+      {
+         if (n == line)
+            continue;
+
+         int other_vert;
+         int which_side;
+
+         if (LineDefs[n].start == cur_vert)
+         {
+            other_vert = LineDefs[n].end;
+            which_side = 1;
+         }
+         else if (LineDefs[n].end == cur_vert)
+         {
+            other_vert = LineDefs[n].start;
+            which_side = 2;
+         }
+         else
+            continue;
+
+         // found adjoining linedef
+         
+         double angle = angle_between_linedefs (prev_vert, cur_vert,
+            other_vert);
+         
+         if (! is_obj (next_line) || angle < best_angle)
+         {
+            next_line = n;
+            next_vert = other_vert;
+            next_side = which_side;
+            
+            best_angle = angle;
+         }
+
+         // Continue the search
+      }
+ 
+      line = next_line;
+      side = next_side;
+
+#if (DEBUG_PATH)
+      fprintf(stderr, "PATH NEXT: line %d  side %d  vert %d  angle %1.6f\n",
+         line, side, next_vert, best_angle);
+#endif
+
+      // None ?  Path cannot be closed
+      if (! is_obj (line))
+         return 0;
+
+      // Line already seen ?  Under normal circumstances this won't
+      // happen, but it _can_ happen and indicates a non-closed
+      // structure
+      if (ld_side1.get (line) || ld_side2.get (line))
+         return 0;
+
+      if (side == 1)
+         ld_side1.set (line);
+      else
+         ld_side2.set (line);
+       
+      prev_vert = cur_vert;
+      cur_vert = next_vert;
+   }
+
+#if (DEBUG_PATH)
+      fprintf(stderr, "PATH CLOSED !\n");
+#endif
+
+   return 1;
+}
+
+/*
+   update the side on a single linedef, using the given sector
+   reference.  Will create a new sidedef if necessary.
+ */
+static void super_set_sector_on_side (int line, wad_sdn_t& side,
+   wad_sdn_t& other, int side_no, int sector)
+{
+   if (is_obj (side) && SideDefs[side].sector == sector)
+   {
+      // there was no change.
+      return;
+   }
+   
+   int must_flip = 0;
+
+   if (! is_obj (side))
+   {
+      // if we're adding a sidedef to a line that has no sides, and
+      // the sidedef would be the 2nd one, then flip the linedef.
+      // Thus we don't end up with invalid lines -- i.e. ones with a
+      // left side but no right side.
+
+      if (! is_obj (other) && side_no == 2)
+         must_flip = 1;
+
+      InsertObject (OBJ_SIDEDEFS, OBJ_NO_NONE, 0, 0);
+      side = NumSideDefs - 1;
+
+      // if we're adding a second side to the linedef, clear out some
+      // of the properties that aren't needed anymore: middle texture,
+      // two-sided flag, and impassible flag.
+      
+      if (is_obj (other))
+      {
+         strncpy (SideDefs[side].tex3,  "-", WAD_TEX_NAME);
+         strncpy (SideDefs[other].tex3, "-", WAD_TEX_NAME);
+
+         LineDefs[line].flags |=  4;  // Set the 2S bit
+         LineDefs[line].flags &= ~1;  // Clear the Im bit
+      }
+   }
+
+   SideDefs[side].sector = sector;
+   
+   if (must_flip)
+   {
+      int temp = LineDefs[line].start;
+      LineDefs[line].start = LineDefs[line].end;
+      LineDefs[line].end = temp;
+
+      temp = side; 
+      side = other; 
+      other = temp;
+   }
+
+   MadeChanges = 1;
+   MadeMapChanges = 1;
+}
+
+static int super_find_sector_model (bitvec_c& ld_side1,
+    bitvec_c& ld_side2)
+{
+   for (int line=0; line < NumLineDefs; line++)
+   {
+      int side1 = LineDefs[line].sidedef1;
+      int side2 = LineDefs[line].sidedef2;
+
+      if (ld_side1.get (line))
+         if (is_obj (side2))
+            return SideDefs[side2].sector;
+
+      if (ld_side2.get (line))
+         if (is_obj (side1))
+            return SideDefs[side1].sector;
+   }
+
+   return OBJ_NO_NONE;
+}
+
+
+/*
+   Change the closed sector at the pointer
+
+   "sector" here really means a bunch of sidedefs that all face
+   inward to the current area under the mouse cursor.  Two basic
+   operations: (a) set the sidedef sector references to a completely
+   new sector, or (b) set them to an existing sector.  This is
+   controlled by the `new_sec' parameter.
+
+   -AJA- 2001-05-08
+ */
+
+void SuperSectorSelector (int map_x, int map_y, int new_sec)
+{
+   int line, side;
+   char msg_buf[200];
+
+   line = find_linedef_for_area (map_x, map_y, side);
+
+   if (! is_obj (line))
+   {
+      Beep ();
+      sprintf (msg_buf, "Chosen area is not closed");
+      Notify (-1, -1, msg_buf, NULL);
+      return;
+   }
+
+   bitvec_c ld_side1 (NumLineDefs);
+   bitvec_c ld_side2 (NumLineDefs);
+   
+   int closed = select_sides_in_closed_path (ld_side1, ld_side2,
+      line, side);
+
+   if (! closed)
+   {
+      Beep ();
+      sprintf (msg_buf, "Area chosen is not closed");
+      Notify (-1, -1, msg_buf, NULL);
+      return;
+   }
+
+   // -AJA- FIXME: look for "islands", closed linedef paths that lie
+   // completely inside the area, i.e. not connected to the main path.
+   // Example: the two pillars at the start of MAP01 of DOOM 2.  See
+   // GetOppositeSector() and the end of SplitSector() for a possible
+   // algorithm.
+   
+   if (! is_obj (new_sec))
+   {
+      int model = super_find_sector_model (ld_side1, ld_side2);
+      InsertObject (OBJ_SECTORS, model, 0, 0);
+      new_sec = NumSectors - 1;
+   }
+   
+   for (line=0; line < NumLineDefs; line++)
+   {
+      if (ld_side1.get (line))
+         super_set_sector_on_side (line, LineDefs[line].sidedef1,
+            LineDefs[line].sidedef2, 1, new_sec);
+
+      else if (ld_side2.get (line))
+         super_set_sector_on_side (line, LineDefs[line].sidedef2,
+            LineDefs[line].sidedef1, 2, new_sec);
+   }
+}
+
 /* end of file */
--- yadex-1.7.0.orig/src/s_prop.cc
+++ yadex-1.7.0/src/s_prop.cc
@@ -259,4 +259,67 @@
   }
 }
 
+/*
+ * 	InputSectorType
+ * 	Let the user select a sector type number and return it
+ * 	Returns 0 if OK, <>0 if cancelled
+ */
+int InputSectorType (int x0, int y0, int *number)
+{
+  int	val;
+  val = 0;
+  *number = 0;
+  Menu_data_st menudata (stdef);
+	if (DisplayMenuList (x0 , y0, "Select type", menudata, &val)
+	  < 0)
+	  return 1;
+  // KLUDGE last element of stdef means "enter value"
+  if (val == al_lcount (stdef) - 1)
+  	{
+	  val = InputIntegerValue (x0 + 84,
+	    y0 + BOX_BORDER + (3 + val) * FONTH,
+	    -32768, 32767, 0);
+	  if (val == IIV_CANCEL)  // [Esc]
+	    return 1;
+	}
+	else
+	{
+	  if (al_lseek (stdef, val, SEEK_SET))
+	    fatal_error ("%s SP1 (%s)\n",
+	      msg_unexpected, al_astrerror (al_aerrno));
+	  val = CUR_STDEF->number;
+	}
+  if (val < 0) return 1;  //unsuccessful
+  *number = val;
+  return 0;               //successful
+}
+
+/*
+ *   TransferSectorProperties
+ *
+ *   -AJA- 2001-05-27
+ */
+void TransferSectorProperties (int src_sector, SelPtr sectors)
+{
+   SelPtr cur;
+
+   for (cur=sectors; cur; cur=cur->next)
+   {
+      if (! is_obj(cur->objnum))
+         continue;
+
+      strncpy (Sectors[cur->objnum].floort, Sectors[src_sector].floort,
+            WAD_FLAT_NAME);
+      strncpy (Sectors[cur->objnum].ceilt, Sectors[src_sector].ceilt,
+            WAD_FLAT_NAME);
+
+      Sectors[cur->objnum].floorh  = Sectors[src_sector].floorh;
+      Sectors[cur->objnum].ceilh   = Sectors[src_sector].ceilh;
+      Sectors[cur->objnum].light   = Sectors[src_sector].light;
+      Sectors[cur->objnum].special = Sectors[src_sector].special;
+      Sectors[cur->objnum].tag     = Sectors[src_sector].tag;
+
+      MadeChanges = 1;
+   }
+}
 
--- yadex-1.7.0.orig/src/s_split.cc
+++ yadex-1.7.0/src/s_split.cc
@@ -36,6 +36,7 @@
 #include "s_linedefs.h"
 #include "selectn.h"
 #include "x_hover.h"
+#include "entry.h"
 
 
 /*
--- yadex-1.7.0.orig/src/sanity.cc
+++ yadex-1.7.0/src/sanity.cc
@@ -67,10 +67,10 @@
   assert_size (i16, 2);
   assert_size (u32, 4);
   assert_size (i32, 4);
-  assert_size (struct LineDef, 14);
+  assert_size (struct LineDef, 18);
   assert_size (struct Sector,  26);
   assert_size (struct SideDef, 30);
-  assert_size (struct Thing,   10);
+  assert_size (struct Thing,   20);
   assert_size (struct Vertex,   4);
   assert_wrap (u8,          255,           0);
   assert_wrap (i8,          127,        -128);
--- yadex-1.7.0.orig/src/r_images.cc
+++ yadex-1.7.0/src/r_images.cc
@@ -0,0 +1,400 @@
+/*
+ *	r_images.cc
+ *	AJA 2002-04-23 (based on textures.cc and flats.cc)
+ */
+
+
+/*
+This file is part of Yadex.
+
+Yadex incorporates code from DEU 5.21 that was put in the public domain in
+1994 by Raphaël Quinet and Brendon Wyber.
+
+The rest of Yadex is Copyright © 1997-2000 André Majorel.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+
+#include "yadex.h"
+#ifdef Y_X11
+#include <X11/Xlib.h>
+#endif
+#include "dialog.h"
+#include "game.h"      /* yg_picture_format */
+#include "gfx.h"
+#include "levels.h"
+#include "lists.h"
+#include "patchdir.h"
+#include "pic2img.h"
+#include "sticker.h"
+#include "flats.h"
+#include "textures.h"
+#include "wadfile.h"
+#include "wads.h"
+#include "wadres.h"
+#include "wstructs.h"
+
+#include "r_images.h"
+
+
+/*
+ *	flat_list_entry_match
+ *	Function used by bsearch() to locate a particular 
+ *	flat in the FTexture.
+ */
+static int flat_list_entry_match (const void *key, const void *flat_list_entry)
+{
+return y_strnicmp ((const char *) key,
+      ((const flat_list_entry_t *) flat_list_entry)->name,
+      WAD_FLAT_NAME);
+}
+
+
+/*
+ *  load a flat into a new image.  NULL if not found.
+ */
+
+Img * Flat2Img (const wad_flat_name_t& fname)
+{
+char name[WAD_FLAT_NAME + 1];
+strncpy (name, fname, WAD_FLAT_NAME);
+name[WAD_FLAT_NAME] = 0;
+
+flat_list_entry_t *flat = (flat_list_entry_t *)
+   bsearch (name, flat_list, NumFTexture, sizeof *flat_list,
+         flat_list_entry_match);
+
+if (! flat)  // Not found in list
+   return 0;
+
+int width  = DOOM_FLAT_WIDTH;  // Big deal !
+int height = DOOM_FLAT_HEIGHT;
+
+const Wad_file *wadfile = flat->wadfile;
+wadfile->seek (flat->offset);
+
+Img *img = new Img (width, height, false);
+
+wadfile->read_bytes (img->wbuf (), (long) width * height);
+
+return img;
+}
+
+
+/*
+ * load a wall texture ("TEXTURE1" or "TEXTURE2" object) into an image.
+ * Returns NULL if not found or error.
+ */
+
+Img * Tex2Img (const wad_tex_name_t& texname)
+{
+MDirPtr  dir = 0;	/* main directory pointer to the TEXTURE* entries */
+i32     *offsets;	/* array of offsets to texture names */
+int      n;		/* general counter */
+i16      width, height;	/* size of the texture */
+i16      npatches;	/* number of wall patches used to build this texture */
+i32      numtex;	/* number of texture names in TEXTURE* list */
+i32      texofs;	/* offset in the wad file to the texture data */
+char     tname[WAD_TEX_NAME + 1];	/* texture name */
+char     picname[WAD_PIC_NAME + 1];	/* wall patch name */
+bool     have_dummy_bytes;
+int      header_size;
+int      item_size;
+
+char name[WAD_TEX_NAME + 1];
+strncpy (name, texname, WAD_TEX_NAME);
+name[WAD_TEX_NAME] = 0;
+
+// Iwad-dependant details
+if (yg_texture_format == YGTF_NAMELESS)
+   {
+   have_dummy_bytes = true;
+   header_size      = 14;
+   item_size        = 10;
+   }
+else if (yg_texture_format == YGTF_NORMAL)
+   {
+   have_dummy_bytes = true;
+   header_size      = 14;
+   item_size        = 10;
+   }
+else if (yg_texture_format == YGTF_STRIFE11)
+   {
+   have_dummy_bytes = false;
+   header_size      = 10;
+   item_size        = 6;
+   }
+else
+   {
+   nf_bug ("Bad texture format %d.", (int) yg_texture_format);
+   return 0;
+   }
+
+/* offset for texture we want. */
+texofs = 0;
+// Doom alpha 0.4 : "TEXTURES", no names
+if (yg_texture_lumps == YGTL_TEXTURES && yg_texture_format == YGTF_NAMELESS)
+   {
+   dir = FindMasterDir (MasterDir, "TEXTURES");
+   if (dir != NULL)
+      {
+      dir->wadfile->seek (dir->dir.start);
+      dir->wadfile->read_i32 (&numtex);
+      if (WAD_TEX_NAME < 7) nf_bug ("WAD_TEX_NAME too small");  // Sanity
+      if (! y_strnicmp (name, "TEX", 3)
+            && isdigit (name[3])
+            && isdigit (name[4])
+            && isdigit (name[5])
+            && isdigit (name[6])
+            && name[7] == '\0')
+         {
+         long num;
+         if (sscanf (name + 3, "%4ld", &num) == 1
+               && num >= 0 && num < numtex)
+            {
+            dir->wadfile->seek (dir->dir.start + 4 + 4 * num);
+            dir->wadfile->read_i32 (&texofs);
+            texofs += dir->dir.start;
+            }
+         }
+      }
+   }
+// Doom alpha 0.5 : only "TEXTURES"
+else if (yg_texture_lumps == YGTL_TEXTURES
+      && (yg_texture_format == YGTF_NORMAL || yg_texture_format == YGTF_STRIFE11))
+   {
+   // Is it in TEXTURES ?
+   dir = FindMasterDir (MasterDir, "TEXTURES");
+   if (dir != NULL)  // (Theoretically, it should always exist)
+      {
+      dir->wadfile->seek (dir->dir.start);
+      dir->wadfile->read_i32 (&numtex);
+      /* read in the offsets for texture1 names and info. */
+      offsets = (i32 *) GetMemory ((long) numtex * 4);
+      dir->wadfile->read_i32 (offsets, numtex);
+      for (n = 0; n < numtex && !texofs; n++)
+         {
+         dir->wadfile->seek (dir->dir.start + offsets[n]);
+         dir->wadfile->read_bytes (&tname, WAD_TEX_NAME);
+         if (!y_strnicmp (tname, name, WAD_TEX_NAME))
+            texofs = dir->dir.start + offsets[n];
+         }
+      FreeMemory (offsets);
+      }
+   }
+// Other iwads : "TEXTURE1" and "TEXTURE2"
+else if (yg_texture_lumps == YGTL_NORMAL
+      && (yg_texture_format == YGTF_NORMAL || yg_texture_format == YGTF_STRIFE11))
+   {
+   // Is it in TEXTURE1 ?
+   dir = FindMasterDir (MasterDir, "TEXTURE1");
+   if (dir != NULL)  // (Theoretically, it should always exist)
+      {
+      dir->wadfile->seek (dir->dir.start);
+      dir->wadfile->read_i32 (&numtex);
+      /* read in the offsets for texture1 names and info. */
+      offsets = (i32 *) GetMemory ((long) numtex * 4);
+      dir->wadfile->read_i32 (offsets, numtex);
+      for (n = 0; n < numtex && !texofs; n++)
+         {
+         dir->wadfile->seek (dir->dir.start + offsets[n]);
+         dir->wadfile->read_bytes (&tname, WAD_TEX_NAME);
+         if (!y_strnicmp (tname, name, WAD_TEX_NAME))
+            texofs = dir->dir.start + offsets[n];
+         }
+      FreeMemory (offsets);
+      }
+   // Well, then is it in TEXTURE2 ?
+   if (texofs == 0)
+      {
+      dir = FindMasterDir (MasterDir, "TEXTURE2");
+      if (dir != NULL)  // Doom II has no TEXTURE2
+         {
+         dir->wadfile->seek (dir->dir.start);
+         dir->wadfile->read_i32 (&numtex);
+         /* read in the offsets for texture2 names */
+         offsets = (i32 *) GetMemory ((long) numtex * 4);
+         dir->wadfile->read_i32 (offsets, numtex);
+         for (n = 0; n < numtex && !texofs; n++)
+            {
+            dir->wadfile->seek (dir->dir.start + offsets[n]);
+            dir->wadfile->read_bytes (&tname, WAD_TEX_NAME);
+            if (!y_strnicmp (tname, name, WAD_TEX_NAME))
+               texofs = dir->dir.start + offsets[n];
+            }
+         FreeMemory (offsets);
+         }
+      }
+   }
+else
+   nf_bug ("Invalid texture_format/texture_lumps combination.");
+
+/* texture name not found */
+if (texofs == 0)
+   return 0;
+
+/* read the info for this texture */
+i32 header_ofs;
+if (yg_texture_format == YGTF_NAMELESS)
+   header_ofs = texofs;
+else
+   header_ofs = texofs + WAD_TEX_NAME;
+dir->wadfile->seek (header_ofs + 4);
+dir->wadfile->read_i16 (&width);
+dir->wadfile->read_i16 (&height);
+if (have_dummy_bytes)
+   {
+   i16 dummy;
+   dir->wadfile->read_i16 (&dummy);
+   dir->wadfile->read_i16 (&dummy);
+   }
+dir->wadfile->read_i16 (&npatches);
+
+/* Compose the texture */
+Img *texbuf = new Img (width, height, false);
+
+/* Paste onto the buffer all the patches that the texture is
+   made of. */
+for (n = 0; n < npatches; n++)
+   {
+   i16 xofs, yofs;	// offset in texture space for the patch
+   i16 pnameind;	// index of patch in PNAMES
+
+   dir->wadfile->seek (header_ofs + header_size + (long) n * item_size);
+   dir->wadfile->read_i16 (&xofs);
+   dir->wadfile->read_i16 (&yofs);
+   dir->wadfile->read_i16 (&pnameind);
+
+   if (have_dummy_bytes)
+      {
+      i16 stepdir;
+      i16 colormap;
+      dir->wadfile->read_i16 (&stepdir);   // Always 1, unused.
+      dir->wadfile->read_i16 (&colormap);  // Always 0, unused.
+      }
+
+   /* AYM 1998-08-08: Yes, that's weird but that's what Doom
+      does. Without these two lines, the few textures that have
+      patches with negative y-offsets (BIGDOOR7, SKY1, TEKWALL1,
+      TEKWALL5 and a few others) would not look in the texture
+      viewer quite like in Doom. This should be mentioned in
+      the UDS, by the way. */
+   if (yofs < 0)
+      yofs = 0;
+
+   Lump_loc loc;
+      {
+      wad_pic_name_t *wname = patch_dir.name_for_num (pnameind);
+      if (wname == 0)
+         {
+         warn ("texture \"%.*s\": patch %2d has bad index %d.\n",
+               WAD_TEX_NAME, tname, (int) n, (int) pnameind);
+         continue;
+         }
+      patch_dir.loc_by_name ((const char *) *wname, loc);
+      *picname = '\0';
+      strncat (picname, (const char *) *wname, sizeof picname - 1);
+      }
+
+   if (LoadPicture (*texbuf, picname, loc, xofs, yofs, 0, 0))
+      warn ("texture \"%.*s\": patch \"%.*s\" not found.\n",
+            WAD_TEX_NAME, tname, WAD_PIC_NAME, picname);
+   }
+
+return texbuf;
+}
+
+
+/* --- ImageCache methods --- */
+
+
+Img *ImageCache::GetFlat (const wad_flat_name_t& fname)
+{
+std::string f_str = WadToString(fname);
+
+flat_map_t::iterator P = flats.find (f_str);
+
+if (P != flats.end ())
+   return P->second;
+
+// flat not in the list yet.  Add it.
+
+Img *result = Flat2Img (fname);
+flats[f_str] = result;
+
+// note that a NULL return from Flat2Img is OK, it means that no
+// such flat exists.  Our renderer will revert to using a solid
+// colour.
+
+return result;
+}
+
+
+Img *ImageCache::GetTex (const wad_tex_name_t& tname)
+{
+if (tname[0] == 0 || tname[0] == '-')
+   return 0;
+
+std::string t_str = WadToString(tname);
+
+tex_map_t::iterator P = textures.find (t_str);
+
+if (P != textures.end ())
+   return P->second;
+
+// texture not in the list yet.  Add it.
+
+Img *result = Tex2Img (tname);
+textures[t_str] = result;
+
+// note that a NULL return from Tex2Img is OK, it means that no
+// such texture exists.  Our renderer will revert to using a solid
+// colour.
+
+return result;
+}
+
+
+Img *ImageCache::GetSprite (const wad_ttype_t& type)
+{
+sprite_map_t::iterator P = sprites.find (type);
+
+if (P != sprites.end ())
+   return P->second;
+
+// sprite not in the list yet.  Add it.
+
+Img *result = 0;
+
+const char *sprite_root = get_thing_sprite (type);
+if (sprite_root)
+   {
+   Lump_loc loc;
+   wad_res.sprites.loc_by_root (sprite_root, loc);
+   result = new Img ();
+
+   if (LoadPicture (*result, sprite_root, loc, 0, 0) != 0)
+      {
+      delete result;
+      result = 0;
+      }
+   }
+
+// note that a NULL image is OK.  Our renderer will just ignore the
+// missing sprite.
+
+sprites[type] = result;
+return result;
+}
--- yadex-1.7.0.orig/src/wadlist.cc
+++ yadex-1.7.0/src/wadlist.cc
@@ -24,6 +24,9 @@
 You should have received a copy of the GNU General Public License along with
 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 Place, Suite 330, Boston, MA 02111-1307, USA.
+
+patched using a patch from redhat, 18Aug2009, brian at portaboom dot com
+https://bugzilla.redhat.com/attachment.cgi?id=126273
 */
 
 
@@ -52,6 +55,7 @@
 
 Wad_list_priv::Wad_list_priv ()
 {
+  iter = list.begin ();
   rewound = true;
 }
 
@@ -80,6 +84,7 @@
  */
 void Wad_list::rewind () const
 {
+  priv->iter = priv->list.begin ();
   priv->rewound = true;
 }
 
@@ -98,10 +103,7 @@
 bool Wad_list::get (Wad_file *& wf)
 {
   if (priv->rewound)
-  {
-    priv->iter = priv->list.begin ();
     priv->rewound = false;
-  }
   else
     ++priv->iter;
 
@@ -119,10 +121,7 @@
 bool Wad_list::get (const Wad_file *& wf) const
 {
   if (priv->rewound)
-  {
-    priv->iter = priv->list.begin ();
     priv->rewound = false;
-  }
   else
     ++priv->iter;
 
@@ -157,26 +156,12 @@
  */
 void Wad_list::del ()
 {
-  list_t::iterator i;
-
-  if (priv->rewound)
-  {
-    i = priv->list.begin ();
-  }
-  else
-  {
-    i = priv->iter;
-  }
-  if (i == priv->list.end ())
+  if (priv->iter == priv->list.end ())
   {
     nf_bug ("Wad_list::del: attempt to delete last item");
     return;
   }
-  priv->iter = priv->list.erase (i);
+  priv->iter = priv->list.erase (priv->iter);
   if (priv->iter == priv->list.begin ())
-  {
-    priv->iter = 0;			// Catch bugs
     priv->rewound = true;
-  }
 }
-
--- yadex-1.7.0.orig/src/r_render.h
+++ yadex-1.7.0/src/r_render.h
@@ -0,0 +1,14 @@
+/*
+ *	r_render.h
+ *	AJA 2002-04-27
+ */
+
+
+#ifndef YH_R_RENDER  /* DO NOT INSERT ANYTHING BEFORE THIS LINE */
+#define YH_R_RENDER
+
+
+void Render3D ();
+
+
+#endif  /* DO NOT ADD ANYTHING AFTER THIS LINE */
--- yadex-1.7.0.orig/src/config.h
+++ yadex-1.7.0/src/config.h
@@ -0,0 +1,14 @@
+// DO NOT EDIT -- generated by ./configure
+
+//#define Y_DOS
+#define Y_UNIX
+//#define Y_BGI
+#define Y_X11
+#define Y_GETTIMEOFDAY
+#define Y_NANOSLEEP
+#define Y_SNPRINTF
+#define Y_USLEEP
+
+extern const char *yadex_etc_path[];
+extern const char *yadex_share_path[];
+
--- yadex-1.7.0.orig/src/yadex.h
+++ yadex-1.7.0/src/yadex.h
@@ -479,6 +479,7 @@
 
 // l_prop.cc (previously in editobj.cc)
 void LinedefProperties (int x0, int y0, SelPtr obj);
+void TransferLinedefProperties (int src_linedef, SelPtr linedefs);
 
 // l_unlink.cc
 void unlink_sidedef (SelPtr linedefs, int side1, int side2);
@@ -541,13 +542,16 @@
 void DistributeSectorCeilings (SelPtr); /* SWAP! */
 void RaiseOrLowerSectors (SelPtr obj);
 void BrightenOrDarkenSectors (SelPtr obj);
+void SuperSectorSelector (int map_x, int map_y, int new_sec);
 
 // s_prop.cc (previously in editobj.cc)
 void SectorProperties (int x0, int y0, SelPtr obj);
+void TransferSectorProperties (int src_sector, SelPtr sectors);
 
 // s_split.cc (previously in objects.cc)
 void SplitSector (int, int); /* SWAP! */
 void SplitLineDefsAndSector (int, int); /* SWAP! */
+void MultiSplitLineDefsAndSector (int, int); /* SWAP! */
 
 // swapmem.cc
 void InitSwap (void);
@@ -560,6 +564,7 @@
 // selrect.cc
 // t_prop.c (previously in editobj.c)
 void ThingProperties (int x0, int y0, SelPtr obj);
+void TransferThingProperties (int src_thing, SelPtr things);
 
 // v_merge.cc
 void DeleteVerticesJoinLineDefs (SelPtr ); /* SWAP! */
--- yadex-1.7.0.orig/src/wstructs.h
+++ yadex-1.7.0/src/wstructs.h
@@ -84,14 +84,30 @@
 typedef i16 wad_tflags_t;
 struct Thing
 {
+  i16              tid;
   wad_coord_t      xpos;		// FIXME rename to "x"
   wad_coord_t      ypos;		// FIXME rename to "y"
+  wad_z_t          height;
   wad_tangle_t     angle;
   wad_ttype_t      type;
   wad_tflags_t     when;		// FIXME rename to "flags"
+  u8               special;
+  u8               arg1;
+  u8               arg2;
+  u8               arg3;
+  u8               arg4;
+  u8               arg5;
 };
 typedef struct
 {
+  wad_coord_t      xpos;       // FIXME rename to "x"
+  wad_coord_t      ypos;       // FIXME rename to "y"
+  wad_tangle_t     angle;
+  wad_ttype_t      type;
+  wad_tflags_t     when;       // FIXME rename to "flags"
+} wad_doom_thing_t;
+typedef struct
+{
   i16              tid;
   wad_coord_t      x;
   wad_coord_t      y;
@@ -121,11 +137,25 @@
   wad_ldflags_t flags;
   wad_ldtype_t  type;
   wad_tag_t     tag;
+  u8            arg2;
+  u8            arg3;
+  u8            arg4;
+  u8            arg5;
   wad_sdn_t     sidedef1;		// # of first (right) sidedef
   wad_sdn_t     sidedef2;		// # of second (left) sidedef or 0xffff
 };
 typedef struct
 {
+  wad_vn_t      start;         // # of start vertex
+  wad_vn_t      end;           // # of end vertex
+  wad_ldflags_t flags;
+  wad_ldtype_t  type;
+  wad_tag_t     tag;
+  wad_sdn_t     sidedef1;      // # of first (right) sidedef
+  wad_sdn_t     sidedef2;      // # of second (left) sidedef or 0xffff
+} wad_doom_linedef_t;
+typedef struct
+{
   wad_vn_t      start;
   wad_vn_t      end;
   wad_ldflags_t flags;
@@ -197,8 +227,11 @@
   WAD_LL_SECTORS,
   WAD_LL_REJECT,
   WAD_LL_BLOCKMAP,
-		      // Hexen has a BEHAVIOR lump here
-  WAD_LL__
+  WAD_LL_BEHAVIOR,
+
+  WAD_LL__MAX,
+  WAD_LL__HEXEN = WAD_LL__MAX,
+  WAD_LL__DOOM = WAD_LL_BEHAVIOR
 } wad_level_lump_no_t;
 
 typedef struct
@@ -207,7 +240,7 @@
   size_t item_size;
 } wad_level_lump_def_t;
 
-const wad_level_lump_def_t wad_level_lump[WAD_LL__] =
+const wad_level_lump_def_t wad_level_lump[WAD_LL__MAX] =
 {
   { 0,          0                 },  // Label -- no fixed name
   { "THINGS",   WAD_THING_BYTES   },
@@ -219,8 +252,8 @@
   { "NODES",    0                 },
   { "SECTORS",  WAD_SECTOR_BYTES  },
   { "REJECT",   0                 },
-  { "BLOCKMAP", 0                 }
-				      // Hexen has a BEHAVIOR lump here
+  { "BLOCKMAP", 0                 },
+  { "BEHAVIOR", 0                 }
 };
 
 
--- yadex-1.7.0.orig/src/t_prop.cc
+++ yadex-1.7.0/src/t_prop.cc
@@ -36,17 +36,18 @@
 #include "gfx.h"
 #include "levels.h"
 #include "oldmenus.h"
+#include "objid.h"
+#include "objects.h"
 #include "selectn.h"
 #include "things.h"
 
-
 /*
  *	Private functions prototypes
  */
-static int InputThingType (int x0, int y0, int *number);
 static const char *PrintThinggroup (void *ptr);
 static const char *PrintThingdef (void *ptr);
-
+int InputThingType (int x0, int y0, int *number);
+int InputLinedefType (int x0, int y0, int *number);
 
 /*
  *	ThingProperties
@@ -60,9 +61,9 @@
 SelPtr cur;
 int    subwin_y0;
 
-for (n = 0; n < 6; n++)
+for (n = 0; n < 14; n++)
    menustr[n] = (char *) GetMemory (60);
-sprintf (menustr[5], "Edit thing #%d", obj->objnum);
+sprintf (menustr[13], "Edit thing #%d", obj->objnum);
 sprintf (menustr[0], "Change type          (Current: %s)",
          get_thing_name (Things[obj->objnum].type));
 sprintf (menustr[1], "Change angle         (Current: %s)",
@@ -73,14 +74,47 @@
          Things[obj->objnum].xpos);
 sprintf (menustr[4], "Change Y position    (Current: %d)",
          Things[obj->objnum].ypos);
-val = vDisplayMenu (x0, y0, menustr[5],
+sprintf (menustr[5], "Change Z position    (Current: %d)",
+         Things[obj->objnum].height);
+sprintf (menustr[6], "Change TID           (Current: %d)",
+         Things[obj->objnum].tid);
+sprintf (menustr[7], "Change special       (Current: %d)",
+         Things[obj->objnum].special);
+sprintf (menustr[8], "Change arg1          (Current: %d)",
+         Things[obj->objnum].arg1);
+sprintf (menustr[9], "Change arg2          (Current: %d)",
+         Things[obj->objnum].arg2);
+sprintf (menustr[10], "Change arg3          (Current: %d)",
+         Things[obj->objnum].arg3);
+sprintf (menustr[11], "Change arg4          (Current: %d)",
+         Things[obj->objnum].arg4);
+sprintf (menustr[12], "Change arg5          (Current: %d)",
+         Things[obj->objnum].arg5);
+if (yg_level_format == YGLF_HEXEN)     // Hexen mode
+val = vDisplayMenu (x0, y0, menustr[13],
+   menustr[0], YK_, 0,
+   menustr[1], YK_, 0,
+   menustr[2], YK_, 0,
+   menustr[3], YK_, 0,
+   menustr[4], YK_, 0,
+   menustr[5], YK_, 0,
+   menustr[6], YK_, 0,
+   menustr[7], YK_, 0,
+   menustr[8], YK_, 0,
+   menustr[9], YK_, 0,
+   menustr[10], YK_, 0,
+   menustr[11], YK_, 0,
+   menustr[12], YK_, 0,
+   NULL);
+else
+val = vDisplayMenu (x0, y0, menustr[13],
    menustr[0], YK_, 0,
    menustr[1], YK_, 0,
    menustr[2], YK_, 0,
    menustr[3], YK_, 0,
    menustr[4], YK_, 0,
    NULL);
-for (n = 0; n < 6; n++)
+for (n = 0; n < 14; n++)
    FreeMemory (menustr[n]);
 subwin_y0 = y0 + BOX_BORDER + (2 + val) * FONTH;
 switch (val)
@@ -238,6 +272,90 @@
 	n = val - Things[obj->objnum].ypos;
 	for (cur = obj; cur; cur = cur->next)
 	   Things[cur->objnum].ypos += n;
+   MadeChanges = 1;
+        }
+     break;
+
+  case 6:
+     val = InputIntegerValue (x0 + 42, subwin_y0, -32768, 32767,
+                              Things[obj->objnum].height);
+     if (val != IIV_CANCEL)
+        {
+   n = val - Things[obj->objnum].height;
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].height += n;
+   MadeChanges = 1;
+        }
+     break;
+  case 7:
+     val = InputIntegerValue (x0 + 42, subwin_y0, -32768, 32767,
+                              Things[obj->objnum].tid);
+     if (val != IIV_CANCEL)
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].tid = val;
+   MadeChanges = 1;
+        }
+     break;
+
+  case 8:
+     if (! InputLinedefType (x0 + 42, subwin_y0, &val))
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].special = val;
+   MadeChanges = 1;
+        }
+     break;
+
+  case 9:
+     val = InputIntegerValue (x0 + 42, subwin_y0, 0, 255,
+                              Things[obj->objnum].arg1);
+     if (val != IIV_CANCEL)
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].arg1 = val;
+   MadeChanges = 1;
+        }
+     break;
+
+  case 10:
+     val = InputIntegerValue (x0 + 42, subwin_y0, 0, 255,
+                              Things[obj->objnum].arg2);
+     if (val != IIV_CANCEL)
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].arg2 = val;
+   MadeChanges = 1;
+        }
+     break;
+  case 11:
+     val = InputIntegerValue (x0 + 42, subwin_y0, 0, 255,
+                              Things[obj->objnum].arg3);
+     if (val != IIV_CANCEL)
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].arg3 = val;
+   MadeChanges = 1;
+        }
+     break;
+
+  case 12:
+     val = InputIntegerValue (x0 + 42, subwin_y0, 0, 255,
+                              Things[obj->objnum].arg4);
+     if (val != IIV_CANCEL)
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].arg4 = val;
+   MadeChanges = 1;
+        }
+     break;
+  case 13:
+     val = InputIntegerValue (x0 + 42, subwin_y0, 0, 255,
+                              Things[obj->objnum].arg5);
+     if (val != IIV_CANCEL)
+        {
+   for (cur = obj; cur; cur = cur->next)
+      Things[cur->objnum].arg5 = val;
 	MadeChanges = 1;
         }
      break;
@@ -250,7 +368,7 @@
  *	Let the user select a thing number and return it.
  *	Returns 0 if OK, <>0 if cancelled
  */
-static int InputThingType (int x0, int y0, int *number)
+int InputThingType (int x0, int y0, int *number)
 {
 int         r;
 int         tgno = 0;
@@ -331,4 +449,30 @@
 }
 
 
+/*
+ *   TransferThingProperties
+ *
+ *   -AJA- 2001-05-27
+ */
+void TransferThingProperties (int src_thing, SelPtr things)
+{
+   SelPtr cur;
+
+   for (cur=things; cur; cur=cur->next)
+   {
+      if (! is_obj(cur->objnum))
+         continue;
+
+      Things[cur->objnum].angle = Things[src_thing].angle;
+      Things[cur->objnum].type  = Things[src_thing].type;
+      Things[cur->objnum].when  = Things[src_thing].when;
+
+      MadeChanges = 1;
+
+      things_types++;
+      things_angles++;
+   }
+}
+
+
 /* end of file */
--- yadex-1.7.0.orig/src/config.cc
+++ yadex-1.7.0/src/config.cc
@@ -0,0 +1,24 @@
+// DO NOT EDIT -- generated by ./configure
+
+#include "config.h"
+
+extern const char *yadex_etc_path[] =
+{
+  ".",
+  "~/.yadex/%v",
+  "~/.yadex",
+  "/etc/yadex/%v",
+  "/etc/yadex",
+  0
+};
+
+extern const char *yadex_share_path[] =
+{
+  ".",
+  "~/.yadex/%v",
+  "~/.yadex",
+  "/usr/share/yadex/%v",
+  "/usr/share/games/yadex",
+  0
+};
+
--- yadex-1.7.0.orig/src/r_render.cc
+++ yadex-1.7.0/src/r_render.cc
@@ -0,0 +1,1275 @@
+/*
+ *	r_render.cc
+ *	3D Rendering
+ *	AJA 2002-04-21
+ */
+
+
+/*
+This file is part of Yadex.
+
+Yadex incorporates code from DEU 5.21 that was put in the public domain in
+1994 by Raphaël Quinet and Brendon Wyber.
+
+The rest of Yadex is Copyright © 1997-2000 André Majorel.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+
+#include "yadex.h"
+
+#include <math.h>
+#include <vector>
+#include <map>
+#include <algorithm>
+
+#ifdef Y_X11
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#endif
+#include "levels.h"
+#include "wstructs.h"
+#include "gfx.h"
+#include "img.h"
+#include "sticker.h"
+#include "gamesky.h"
+#include "things.h"
+#include "wadres.h"
+#include "objid.h"
+#include "objects.h"
+#include "pic2img.h"
+#include "rgb.h"
+#include "gcolour2.h"
+
+#include "r_render.h"
+#include "r_images.h"
+
+
+#define ML_UPPER_UNPEGGED  0x08
+#define ML_LOWER_UNPEGGED  0x10
+
+
+struct Y_View
+{
+public:
+   int p_type, px, py;
+   // player type and position.
+
+   float x, y; 
+   int z;
+   // view position.
+
+   static const int EYE_HEIGHT = 41;
+   // standard height above the floor.
+
+   float angle;
+   float Sin, Cos;
+   // view direction.
+
+   int sw, sh;
+   Img *screen;
+   // screen image.
+
+   bool texturing;
+   bool sprites;
+   bool walking;
+
+   ImageCache *im_ch;
+
+   int *thing_floors;
+
+   Y_View () { memset (this, 0, sizeof *this); }
+
+   void SetAngle (float new_ang)
+      {
+      angle = new_ang;
+
+      if (angle >= TWOPI)
+         angle -= TWOPI;
+      else if (angle < 0)
+         angle += TWOPI;
+
+      Sin = sin (angle);
+      Cos = cos (angle);
+      }
+
+   void CalcViewZ ()
+      {
+        Objid o;
+        GetCurObject (o, OBJ_SECTORS, int (x), int (y));
+      int secnum = o.num;
+      if (secnum >= 0)
+         z = Sectors[secnum].floorh + EYE_HEIGHT;
+      }
+
+   void ClearScreen ()
+      {
+      memset (screen->wbuf (), colour0, sw * sh);
+      }
+
+   void PutScreen (int x, int y)
+      {
+      DrawScreenBox3D (x, y, x + BOX_BORDER*2 + sw, y + BOX_BORDER*2 + sh);
+
+      Sticker sticker (*screen, true);
+
+      sticker.draw (drw, 't', x + BOX_BORDER, y + BOX_BORDER);
+      }
+
+   void FindThingFloors ()
+   {
+   thing_floors = new int[NumThings];
+
+   for (int i = 0; i < NumThings; i++)
+      {
+        Objid o;
+        GetCurObject (o, OBJ_SECTORS, Things[i].xpos, 
+            Things[i].ypos);
+      int secnum = o.num;
+      
+      if (secnum < 0)
+         thing_floors[i] = 0;
+      else
+         thing_floors[i] = Sectors[secnum].floorh;
+      }
+   }
+};
+
+
+static Y_View view;
+
+
+struct DrawSurf
+{
+public:
+   enum
+      {
+      K_INVIS = 0,
+      K_FLAT,
+      K_TEXTURE
+      };
+   int kind;  
+
+   int h1, h2, tex_h;
+   // heights for the surface (h1 is above h2).
+
+   Img *img;
+   img_pixel_t col;  /* used if img is zero */
+
+   enum
+      {
+      SOLID_ABOVE = 1,
+      SOLID_BELOW = 2
+      };
+   int y_clip;
+
+   /* CTor */
+
+   DrawSurf () { kind = K_INVIS; img = 0; }
+
+   void FindFlat (const wad_flat_name_t& fname, Sector *sec)
+      {
+      if (view.texturing)
+         {
+         img = view.im_ch->GetFlat (fname);
+
+         if (img != 0)
+            return;
+         }
+      col = 0x70 + ((sec - Sectors) % 48);
+      }
+
+   void FindTex (const wad_tex_name_t& tname, LineDef *ld)
+      {
+      if (view.texturing)
+         {
+         img = view.im_ch->GetTex (tname);
+
+         if (img != 0)
+            return;
+         }
+      col = 0x30 + ((ld - LineDefs) % 64);
+
+      if (col >= 0x60)
+         col += 0x70;
+      }
+};
+
+
+struct DrawWall
+{
+public:
+   typedef std::vector<struct DrawWall *> vec_t;
+
+   Thing *th;
+   // when `th' is non-zero, this is actually a sprite, and `ld' and
+   // `sd' will be zero.  Sprites use the info in the `ceil' surface.
+
+   LineDef *ld;
+   SideDef *sd;
+   Sector *sec;
+
+   int side;
+   // which side this wall faces (0 right, 1 left)
+
+   float ang1, dang, cur_ang;
+   float base_ang;
+   // clipped angles
+
+   float dist, t_dist;
+   float normal;
+   // line constants
+
+   double iz1, diz, cur_iz; 
+   double mid_iz;
+   // distance values (inverted, so they can be lerped)
+
+   float spr_tx1;
+   // translate coord, for sprite
+
+   int sx1, sx2;
+   // screen X coordinates
+ 
+   int oy1, oy2;
+   // for sprites, the remembered open space to clip to
+
+   /* surfaces */
+   
+   DrawSurf ceil;
+   DrawSurf upper;
+   DrawSurf lower;
+   DrawSurf floor;
+
+   #define IZ_EPSILON 0.000001
+
+   /* PREDICATES */
+
+   struct MidDistCmp
+      {
+      inline bool operator() (const DrawWall * A, const DrawWall * B) const
+         {
+         return A->mid_iz > B->mid_iz;
+         }
+      };
+
+   struct DistCmp
+      {
+      inline bool operator() (const DrawWall * A, const DrawWall * B) const
+         {
+         if (fabs (A->cur_iz - B->cur_iz) < IZ_EPSILON)
+            return A->diz > B->diz;
+
+         return A->cur_iz > B->cur_iz;
+         }
+      };
+
+   struct SX1Cmp
+      {
+      inline bool operator() (const DrawWall * A, const DrawWall * B) const
+         {
+         return A->sx1 < B->sx1;
+         }
+
+      inline bool operator() (const DrawWall * A, int x) const
+         {
+         return A->sx1 < x;
+         }
+
+      inline bool operator() (int x, const DrawWall * A) const
+         {
+         return x < A->sx1;
+         }
+      };
+
+   struct SX2Less
+      {
+      int x;
+
+      SX2Less (int _x) : x (_x) { }
+
+      inline bool operator() (const DrawWall * A) const
+         {
+         return A->sx2 < x;
+         }
+      };
+
+   /* methods */
+
+   void ComputeWallSurface ()
+      {
+      Sector *front = sec;
+      Sector *back  = 0;
+
+      if (is_obj (side ? ld->sidedef1 : ld->sidedef2))
+         {
+         SideDef *bsd = SideDefs + (side ? ld->sidedef1 : ld->sidedef2);
+
+         if (is_obj (bsd->sector))
+            back = Sectors + bsd->sector;
+         }
+
+      bool sky_upper = back && is_sky (front->ceilt) && is_sky (back->ceilt);
+
+      if ((front->ceilh > view.z || is_sky (front->ceilt)) && ! sky_upper) 
+         {
+         ceil.kind = DrawSurf::K_FLAT;
+         ceil.h1 = +99999;
+         ceil.h2 = front->ceilh;
+         ceil.tex_h = ceil.h2;
+         ceil.y_clip = DrawSurf::SOLID_ABOVE;
+
+         if (is_sky (front->ceilt))
+            ceil.col = sky_colour;
+         else
+            ceil.FindFlat (front->ceilt, front);
+         }
+
+      if (front->floorh < view.z)
+         {
+         floor.kind = DrawSurf::K_FLAT;
+         floor.h1 = front->floorh;
+         floor.h2 = -99999;
+         floor.tex_h = floor.h1;
+         floor.y_clip = DrawSurf::SOLID_BELOW;
+
+         if (is_sky (front->floort))
+            floor.col = sky_colour;
+         else
+            floor.FindFlat (front->floort, front);
+         }
+
+      if (! back)
+         {
+         /* ONE-sided line */
+
+         lower.kind = DrawSurf::K_TEXTURE;
+         lower.h1 = front->ceilh;
+         lower.h2 = front->floorh;
+         lower.y_clip = DrawSurf::SOLID_ABOVE | DrawSurf::SOLID_BELOW;
+
+         lower.FindTex (sd->tex3, ld);
+
+         if (lower.img && (ld->flags & ML_LOWER_UNPEGGED))
+            lower.tex_h = lower.h2 + lower.img->height ();
+         else
+            lower.tex_h = lower.h1;
+         }
+      else
+         {
+         /* TWO-sided line */
+
+         if (back->ceilh < front->ceilh && ! sky_upper)
+            {
+            upper.kind = DrawSurf::K_TEXTURE;
+            upper.h1 = front->ceilh;
+            upper.h2 = back->ceilh;
+            upper.tex_h = upper.h1;
+            upper.y_clip = DrawSurf::SOLID_ABOVE;
+
+            upper.FindTex (sd->tex1, ld);
+
+            if (upper.img && ! (ld->flags & ML_UPPER_UNPEGGED))
+               upper.tex_h = upper.h2 + upper.img->height ();
+            else
+               upper.tex_h = upper.h1;
+            }
+
+         if (back->floorh > front->floorh)
+            {
+            lower.kind = DrawSurf::K_TEXTURE;
+            lower.h1 = back->floorh;
+            lower.h2 = front->floorh;
+            lower.y_clip = DrawSurf::SOLID_BELOW;
+
+            lower.FindTex (sd->tex2, ld);
+
+            if (ld->flags & ML_LOWER_UNPEGGED)
+               lower.tex_h = front->ceilh;
+            else
+               lower.tex_h = lower.h1;
+            }
+         }
+      }
+};
+
+
+struct RendInfo
+{
+public:
+   DrawWall::vec_t walls;
+   // complete set of walls/sprites to draw.
+
+   DrawWall::vec_t active;
+   // the active list.  Pointers here are always duplicates of ones in
+   // the walls list (no need to `delete' any of them).
+
+   std::vector<double> depth_x;  
+   // inverse distances over X range, 0 when empty.
+
+   int open_y1;
+   int open_y2;
+
+   #define Y_SLOPE 1.70
+
+   static void DeleteWall (DrawWall *P)
+      {
+      delete P;
+      }
+
+   ~RendInfo ()
+      {
+      std::for_each (walls.begin (), walls.end (), DeleteWall);
+      
+      walls.clear ();
+      active.clear ();
+      }
+
+   void InitDepthBuf (int width)
+      {
+      depth_x.resize (width);
+
+      std::fill_n (depth_x.begin (), width, 0);
+      }
+
+   static inline float PointToAngle (float x, float y)
+      {
+      if (-0.01 < x && x < 0.01)
+         return (y > 0) ? HALFPI : (3 * HALFPI);
+
+      float angle = atan2(y, x);
+
+      if (angle < 0)
+         angle += TWOPI;
+
+      return angle;
+      }
+
+   static inline int AngleToX (float ang)
+      {
+      float t = tan (HALFPI - ang);
+
+      int x = int (view.sw * t);
+
+      x = (view.sw + x) / 2;
+
+      if (x < 0)
+         x = 0;
+      else if (x > view.sw)
+         x = view.sw;
+
+      return x;
+      }
+
+   static inline float XToAngle (int x)
+      {
+      x = x * 2 - view.sw;
+
+      float ang = HALFPI + atan (x / float (view.sw));
+
+      if (ang < 0)
+         ang = 0;
+      else if (ang > ONEPI)
+         ang = ONEPI;
+
+      return ang;
+      }
+
+   static inline int DeltaToX (double iz, float tx)
+      {
+      int x = int (view.sw * tx * iz);
+
+      x = (x + view.sw) / 2;
+
+      return x;
+      }
+
+   static inline float XToDelta (int x, double iz)
+      {
+      x = x * 2 - view.sw;
+
+      float tx = x / iz / view.sw;
+
+      return tx;
+      }
+
+   static inline int DistToY (double iz, int sec_h)
+      {
+      if (sec_h > 32770)
+         return -9999;
+
+      if (sec_h < -32770)
+         return +9999;
+
+      sec_h -= view.z;
+
+      int y = int (view.sh * sec_h * iz * Y_SLOPE);
+
+      y = (view.sh - y) / 2;
+
+      return y;
+      }
+
+   static inline float YToDist (int y, int sec_h)
+      {
+      sec_h -= view.z;
+
+      y = y * 2 - view.sh;
+
+      if (y == 0)
+         return 999999;
+
+      return view.sh * sec_h * Y_SLOPE / y;
+      }
+
+   static inline float YToSecH (int y, double iz)
+      {
+      y = y * 2 - view.sh;
+
+      return view.z - (float (y) / view.sh / iz / Y_SLOPE);
+      }
+
+   void AddLine (int linenum)
+      {
+      LineDef *ld = LineDefs + linenum;
+
+      if (! is_obj (ld->start) || ! is_obj (ld->end))
+         return;
+
+      float x1 = Vertices[ld->start].x - view.x;
+      float y1 = Vertices[ld->start].y - view.y;
+      float x2 = Vertices[ld->end].x - view.x;
+      float y2 = Vertices[ld->end].y - view.y;
+
+      float tx1 = x1 * view.Sin - y1 * view.Cos;
+      float ty1 = x1 * view.Cos + y1 * view.Sin;
+      float tx2 = x2 * view.Sin - y2 * view.Cos;
+      float ty2 = x2 * view.Cos + y2 * view.Sin;
+
+      // reject line if complete behind viewplane
+      if (ty1 <= 0 && ty2 <= 0)
+         return;
+
+      float angle1 = PointToAngle (tx1, ty1);
+      float angle2 = PointToAngle (tx2, ty2);
+      float span = angle1 - angle2;
+
+      if (span < 0)
+         span += TWOPI;
+
+      int side = 0;
+      SideDef *sd;
+
+      if (span >= ONEPI)
+         side = 1;
+
+      // ignore the line when there is no facing sidedef
+      if (! is_obj (side ? ld->sidedef2 : ld->sidedef1))
+         return;
+
+      sd = SideDefs + (side ? ld->sidedef2 : ld->sidedef1);
+
+      if (! is_obj (sd->sector))
+         return;
+
+      if (side == 1)
+         {
+         float tmp = angle1;
+         angle1 = angle2;
+         angle2 = tmp;
+         }
+
+      // clip angles to view volume
+
+      float base_ang = angle1;
+
+      float leftclip  = (3 * ONEPI / 4);
+      float rightclip = ONEPI / 4;
+
+      float tspan1 = angle1 - rightclip;
+      float tspan2 = leftclip - angle2;
+
+      if (tspan1 < 0) tspan1 += TWOPI;
+      if (tspan2 < 0) tspan2 += TWOPI;
+
+      if (tspan1 > HALFPI)
+         {
+         // Totally off the left edge?
+         if (tspan2 >= ONEPI)
+            return;
+
+         angle1 = leftclip;
+         }
+
+      if (tspan2 > HALFPI)
+         {
+         // Totally off the left edge?
+         if (tspan1 >= ONEPI)
+            return;
+
+         angle2 = rightclip;
+         }
+
+      // convert angles to on-screen X positions
+      int sx1 = AngleToX (angle1);
+      int sx2 = AngleToX (angle2) - 1;
+
+      if (sx1 > sx2)
+         return;
+
+      // compute distance from eye to wall
+      float wdx = x2 - x1;
+      float wdy = y2 - y1;
+
+      float wlen = sqrt (wdx * wdx + wdy * wdy);
+      float dist = fabs ((y1 * wdx / wlen) - (x1 * wdy / wlen));
+
+      if (dist < 0.01)
+         return;
+
+      // compute normal of wall (translated coords)
+      float normal;
+
+      if (side == 1)
+         normal = PointToAngle (ty2 - ty1, tx1 - tx2);
+      else
+         normal = PointToAngle (ty1 - ty2, tx2 - tx1);
+
+      // compute inverse distances
+      double iz1 = cos (normal - angle1) / dist / cos (HALFPI - angle1);
+      double iz2 = cos (normal - angle2) / dist / cos (HALFPI - angle2);
+
+      double diz = (iz2 - iz1) / y_max (1, sx2 - sx1);
+
+      // create drawwall structure
+
+      DrawWall *dw = new DrawWall;
+
+      dw->th = 0;
+      dw->ld = ld;
+      dw->sd = sd;
+      dw->sec = Sectors + sd->sector;
+
+      dw->side = side;
+
+      dw->base_ang = base_ang;
+      dw->ang1 = angle1;
+      dw->dang = (angle2 - angle1) / y_max (1, sx2 - sx1);
+
+      dw->dist = dist;
+      dw->normal = normal;
+      dw->t_dist = tan (base_ang - normal) * dist;
+
+      dw->iz1 = iz1;
+      dw->diz = diz;
+      dw->mid_iz = iz1 + (sx2 - sx1 + 1) * diz / 2;
+
+      dw->sx1 = sx1;  dw->sx2 = sx2;
+
+      walls.push_back (dw);
+      }
+
+   void AddThing (int thingnum)
+      {
+      Thing *th = Things + thingnum;
+
+      float x = th->xpos - view.x;
+      float y = th->ypos - view.y;
+
+      float tx = x * view.Sin - y * view.Cos;
+      float ty = x * view.Cos + y * view.Sin;
+
+      // reject sprite if complete behind viewplane
+      if (ty < 4)
+         return;
+
+      Img *sprite = view.im_ch->GetSprite (th->type);
+      if (! sprite)
+         return;
+
+      float tx1 = tx - sprite->width () / 2.0;
+      float tx2 = tx + sprite->width () / 2.0;
+
+      double iz = 1 / ty;
+
+      int sx1 = DeltaToX (iz, tx1);
+      int sx2 = DeltaToX (iz, tx2) - 1;
+
+      if (sx1 < 0)
+         sx1 = 0;
+
+      if (sx2 >= view.sw)
+         sx2 = view.sw - 1;
+
+      if (sx1 > sx2)
+         return;
+
+      int h2 = view.thing_floors[thingnum];
+      int h1 = h2 + sprite->height ();
+
+      // create drawwall structure
+
+      DrawWall *dw = new DrawWall;
+
+      dw->th = th;
+      dw->ld = 0;
+      dw->sd = 0;
+      dw->sec = 0;
+
+      dw->spr_tx1 = tx1;
+
+      dw->ang1 = dw->dang = 0;
+
+      dw->iz1 = dw->mid_iz = iz;
+      dw->diz = 0;
+
+      dw->sx1 = sx1;  dw->sx2 = sx2;
+
+      dw->ceil.img = sprite;
+      dw->ceil.h1  = h1;
+      dw->ceil.h2  = h2;
+
+      walls.push_back (dw);
+      }
+
+   void ComputeSurfaces ()
+      {
+      DrawWall::vec_t::iterator S;
+
+      for (S = walls.begin (); S != walls.end (); S++)
+         if ((*S)->ld)
+            (*S)->ComputeWallSurface ();
+      }
+
+   void ClipSolids ()
+      {
+      // perform a rough depth sort of the walls and sprites.
+
+      std::sort (walls.begin (), walls.end (), DrawWall::MidDistCmp ());
+
+      // go forwards, from closest to furthest away
+
+      DrawWall::vec_t::iterator S;
+
+      for (S = walls.begin (); S != walls.end (); S++)
+         {
+         DrawWall *dw = (*S);
+
+         if (! dw)
+            continue;
+
+         int one_sided = dw->ld && ! is_obj (dw->ld->sidedef2);
+         int vis_count = dw->sx2 - dw->sx1 + 1;
+
+         for (int x = dw->sx1; x <= dw->sx2; x++)
+            {
+            double iz = dw->iz1 + (dw->diz * (x - dw->sx1));
+
+            if (iz < depth_x[x])
+               vis_count--;
+            else if (one_sided)
+               depth_x[x] = iz;
+            }
+
+         if (vis_count == 0)
+            {
+            delete dw;
+            (*S) = 0;
+            }
+         }
+
+      // remove null pointers
+
+      S = std::remove (walls.begin (), walls.end (), (DrawWall *) 0);
+
+      walls.erase (S, walls.end ());
+      }
+
+   void RenderFlatColumn (DrawWall *dw, DrawSurf& surf,
+         int x, int y1, int y2)
+      {
+      img_pixel_t *buf = view.screen->wbuf ();
+      img_pixel_t *wbuf = surf.img->wbuf ();
+
+      int tw = surf.img->width ();
+      int th = surf.img->height ();
+
+      float ang = XToAngle (x);
+      float modv = cos (ang - HALFPI);
+
+      float t_cos = cos (ONEPI + -view.angle + ang) / modv;
+      float t_sin = sin (ONEPI + -view.angle + ang) / modv;
+
+      buf += x + y1 * view.sw;
+
+      for (; y1 <= y2; y1++, buf += view.sw)
+         {
+         float dist = YToDist (y1, surf.tex_h);
+
+         int tx = int ( view.x + t_sin * dist) & (tw - 1);
+         int ty = int (-view.y - t_cos * dist) & (th - 1);
+
+         *buf = wbuf[ty * tw + tx];
+         }
+      }
+
+   void RenderTexColumn (DrawWall *dw, DrawSurf& surf,
+         int x, int y1, int y2)
+      {
+      img_pixel_t *buf = view.screen->wbuf ();
+      img_pixel_t *wbuf = surf.img->wbuf ();
+
+      int tw = surf.img->width ();
+      int th = surf.img->height ();
+
+      /* compute texture X coord */
+
+      int tx = int (dw->t_dist - tan (dw->cur_ang - dw->normal) * dw->dist);
+
+      tx = (dw->sd->xoff + tx) & (tw - 1);
+
+      /* compute texture Y coords */
+
+      float base_h = surf.tex_h + dw->sd->yoff;
+
+      float h1 = base_h - YToSecH (y1, dw->cur_iz);
+      float dh = base_h - YToSecH (y2, dw->cur_iz);
+
+      dh = (dh - h1) / y_max (1, y2 - y1);
+       
+      buf  += x + y1 * view.sw;
+      wbuf += tx;
+
+      for (; y1 <= y2; y1++, h1 += dh, buf += view.sw)
+         {
+         int ty = int (h1) % th;
+
+         // handle negative values (use % twice)
+         ty = (ty + th) % th;
+
+         *buf = wbuf[ty * tw];
+         }
+      }
+
+   void RenderSolidColumn (DrawWall *w, DrawSurf& surf,
+         int x, int y1, int y2)
+      {
+      img_pixel_t *buf = view.screen->wbuf ();
+
+      buf += x + y1 * view.sw;
+       
+      for (; y1 <= y2; y1++, buf += view.sw)
+         {
+         *buf = surf.col;
+         }
+      }
+
+   inline void RenderWallSurface (DrawWall *dw, DrawSurf& surf, 
+         int x)
+      {
+      if (surf.kind == DrawSurf::K_INVIS)
+         return;
+
+      int y1 = DistToY (dw->cur_iz, surf.h1);
+      int y2 = DistToY (dw->cur_iz, surf.h2) - 1;
+
+      if (y1 < open_y1)
+         y1 = open_y1;
+
+      if (y2 > open_y2)
+         y2 = open_y2;
+
+      if (y1 > y2)
+         return;
+
+      /* clip the open region */
+
+      if (surf.y_clip & DrawSurf::SOLID_ABOVE)
+         if (y2 > open_y1)
+            open_y1 = y2;
+
+      if (surf.y_clip & DrawSurf::SOLID_BELOW)
+         if (y1 < open_y2)
+            open_y2 = y1;
+
+      /* fill pixels */
+
+      if (! surf.img)
+         {
+         RenderSolidColumn (dw, surf, x, y1, y2);
+         }
+      else switch (surf.kind)
+         {
+         case DrawSurf::K_FLAT:
+            RenderFlatColumn (dw, surf, x, y1, y2);
+            break;
+
+         case DrawSurf::K_TEXTURE:
+            RenderTexColumn  (dw, surf, x, y1, y2);
+            break;
+         }
+      }
+
+   inline void RenderSprite (DrawWall *dw, int x)
+      {
+      int y1 = DistToY (dw->cur_iz, dw->ceil.h1);
+      int y2 = DistToY (dw->cur_iz, dw->ceil.h2) - 1;
+
+      if (y1 < dw->oy1)
+         y1 = dw->oy1;
+
+      if (y2 > dw->oy2)
+         y2 = dw->oy2;
+
+      if (y1 > y2)
+         return;
+
+      /* fill pixels */
+
+      img_pixel_t *buf = view.screen->wbuf ();
+      img_pixel_t *wbuf = dw->ceil.img->wbuf ();
+
+      int tw = dw->ceil.img->width ();
+      int th = dw->ceil.img->height ();
+
+      int tx = int (XToDelta (x, dw->cur_iz) - dw->spr_tx1);
+
+      if (tx < 0 || tx >= tw)
+         return;
+
+      float h1 = dw->ceil.h1 - YToSecH (y1, dw->cur_iz);
+      float dh = dw->ceil.h1 - YToSecH (y2, dw->cur_iz);
+
+      dh = (dh - h1) / y_max (1, y2 - y1);
+       
+      buf  += x + y1 * view.sw;
+      wbuf += tx;
+
+      for (; y1 <= y2; y1++, h1 += dh, buf += view.sw)
+         {
+         int ty = int (h1);
+
+         if (ty < 0 || ty >= th)
+            continue;
+
+         img_pixel_t pix = wbuf[ty * tw];
+
+         if (pix != IMG_TRANSP)
+            *buf = pix;
+         }
+      }
+
+   void UpdateActiveList (int x)
+      {
+      DrawWall::vec_t::iterator S, E, P;
+
+      bool changes = false;
+
+      // remove walls that have finished.
+
+      S = active.begin ();
+      E = active.end ();
+
+      S = std::remove_if (S, E, DrawWall::SX2Less (x));
+
+      if (S != E)
+         {
+         active.erase (S, E);
+         changes = true;
+         }
+
+      // add new walls that start in this column.
+
+      S = walls.begin ();
+      E = walls.end ();
+
+      S = std::lower_bound (S, E, x, DrawWall::SX1Cmp ());
+      E = std::upper_bound (S, E, x, DrawWall::SX1Cmp ());
+
+      if (S != E)
+         changes = true;
+
+      for (; S != E; S++)
+         {
+         active.push_back (*S);
+         }
+
+      // calculate new depth values
+
+      S = active.begin ();
+      E = active.end ();
+
+      for (P=S; (P != E); P++)
+         {
+         DrawWall *dw = (*P);
+
+         dw->cur_iz = dw->iz1 + dw->diz * (x - dw->sx1);
+
+         if (P != S && (*(P-1))->cur_iz < dw->cur_iz)
+            changes = true;
+
+         dw->cur_ang = dw->ang1 + dw->dang * (x - dw->sx1);
+         }
+
+      // if there are changes, re-sort the active list...
+
+      if (changes)
+         {
+         std::sort (active.begin (), active.end (), DrawWall::DistCmp ());
+         }
+      }
+
+   void RenderWalls ()
+      {
+      // sort walls by their starting column, to allow binary search.
+
+      std::sort (walls.begin (), walls.end (), DrawWall::SX1Cmp ());
+
+      active.clear ();
+
+      for (int x=0; x < view.sw; x++)
+         {
+         // clear vertical depth buffer
+
+         open_y1 = 0;
+         open_y2 = view.sh - 1;
+
+         UpdateActiveList (x);
+
+         // render, front to back
+
+         DrawWall::vec_t::iterator S, E, P;
+
+         S = active.begin ();
+         E = active.end ();
+
+         for (P=S; P != E; P++)
+            {
+            DrawWall *dw = (*P);
+
+            // for things, just remember the open space
+            if (dw->th)
+               {
+               dw->oy1 = open_y1;
+               dw->oy2 = open_y2;
+               continue;
+               }
+
+            RenderWallSurface (dw, dw->ceil,  x);
+            RenderWallSurface (dw, dw->floor, x);
+            RenderWallSurface (dw, dw->upper, x);
+            RenderWallSurface (dw, dw->lower, x);
+
+            if (open_y1 >= open_y2)
+               break;
+            }
+
+         // now render things, back to front
+
+         if (P == E)
+            P--;
+
+         for (; P != (S-1); P--)
+            {
+            DrawWall *dw = (*P);
+
+            if (dw->th)
+               RenderSprite (dw, x);
+            }
+         }
+      }
+
+   void DoRender3D ()
+      {
+      view.ClearScreen ();
+
+      InitDepthBuf (view.sw);
+
+      for (int i=0; i < NumLineDefs; i++)
+         AddLine (i);
+
+      if (view.sprites)
+         for (int j=0; j < NumThings; j++)
+            AddThing (j);
+
+      ClipSolids ();
+      ComputeSurfaces ();
+      RenderWalls ();
+      }
+};
+
+
+static Thing *FindPlayer (int typenum)
+{
+for (int i=0; i < NumThings; i++)
+   if (Things[i].type == typenum)
+      return Things + i;
+
+return 0;
+}
+
+
+/*
+ *  Render a 3D view from the player's position. 
+ */
+
+void Render3D ()
+{
+if (! view.p_type)
+   {
+   view.p_type = THING_PLAYER1;
+   view.px = 99999;
+   }
+
+Thing *player = FindPlayer (view.p_type);
+
+if (! player)
+   {
+   if (view.p_type != THING_DEATHMATCH)
+      view.p_type = THING_DEATHMATCH;
+
+   player = FindPlayer (view.p_type);
+
+   if (! player)
+      return;
+   }
+
+if (view.px != player->xpos || view.py != player->ypos)
+   {
+   // if player moved, re-create view parameters
+
+   view.x = view.px = player->xpos;
+   view.y = view.py = player->ypos;
+
+   view.CalcViewZ ();
+   view.SetAngle (player->angle * ONEPI / 180.0);
+   }
+
+/* create image */
+
+view.sw = 320;
+view.sh = 200;
+
+view.screen = new Img ((unsigned short int) view.sw, (unsigned short int) view.sh, false);
+view.im_ch = new ImageCache;
+
+view.FindThingFloors ();
+
+bool Redraw = true;
+
+/* input loop */
+
+for (;;)
+   {
+   /* render image */
+
+   if (Redraw)
+      {
+      if (view.walking)
+         view.CalcViewZ ();
+
+      RendInfo rend;
+
+      rend.DoRender3D ();
+
+      view.PutScreen (40, 40);
+
+      Redraw = false;
+      }
+
+   /* handle keypress */
+
+   int key = get_key ();
+
+   if (key == YK_ESC || key == 'q')
+      break;
+
+   if ((key & ~YK_SHIFT) == YK_LEFT)
+      {
+      view.SetAngle (view.angle + ONEPI / ((key & YK_SHIFT) ? 4 : 8));
+      Redraw = true;
+      }
+   else if ((key & ~YK_SHIFT) == YK_RIGHT)
+      {
+      view.SetAngle (view.angle -ONEPI / ((key & YK_SHIFT) ? 4 : 8));
+      Redraw = true;
+      }
+   else if ((key & ~YK_SHIFT) == YK_UP)
+      {
+      view.x += view.Cos * ((key & YK_SHIFT) ? 192 : 32);
+      view.y += view.Sin * ((key & YK_SHIFT) ? 192 : 32);
+      Redraw = true;
+      }
+   else if ((key & ~YK_SHIFT) == YK_DOWN)
+      {
+      view.x -= view.Cos * ((key & YK_SHIFT) ? 192 : 32);
+      view.y -= view.Sin * ((key & YK_SHIFT) ? 192 : 32);
+      Redraw = true;
+      }
+   else if (key == 'n' || key == 'N')
+      {
+      view.x -= view.Sin * ((key == 'N') ? 192 : 32);
+      view.y += view.Cos * ((key == 'N') ? 192 : 32);
+      Redraw = true;
+      }
+   else if (key == 'm' || key == 'M')
+      {
+      view.x += view.Sin * ((key == 'M') ? 192 : 32);
+      view.y -= view.Cos * ((key == 'M') ? 192 : 32);
+      Redraw = true;
+      }
+   else if (key == 'd' || key == 'D')
+      {
+      view.z += (key == 'D') ? 128 : 32;
+      Redraw = true;
+      }
+   else if (key == 'c' || key == 'C')
+      {
+      view.z -= (key == 'C') ? 128 : 32;
+      Redraw = true;
+      }
+   else if (key == 't')
+      {
+      view.texturing = ! view.texturing;
+      Redraw = true;
+      }
+   else if (key == 's')
+      {
+      view.sprites = ! view.sprites;
+      Redraw = true;
+      }
+   else if (key == 'w')
+      {
+      view.walking = ! view.walking;
+      Redraw = true;
+      }
+   else if (key)
+      {
+      // key no good, get another one
+      Beep ();
+      }
+   }
+
+/* all done */
+
+delete view.screen;
+view.screen = 0;
+
+delete view.im_ch;
+view.im_ch = 0;
+
+delete[] view.thing_floors;
+view.thing_floors = 0;
+}
+
--- yadex-1.7.0.orig/src/r_images.h
+++ yadex-1.7.0/src/r_images.h
@@ -0,0 +1,69 @@
+/*
+ *	r_images.h
+ *	AJA 2002-04-27
+ */
+
+
+#ifndef YH_R_IMAGES  /* DO NOT INSERT ANYTHING BEFORE THIS LINE */
+#define YH_R_IMAGES
+
+
+#include <map>
+#include <algorithm>
+#include <string>
+
+
+struct ImageCache
+{
+public:
+   typedef std::map<std::string, Img *> flat_map_t;
+   typedef std::map<std::string, Img *> tex_map_t;
+   typedef std::map<wad_ttype_t, Img *> sprite_map_t;
+
+   flat_map_t   flats;
+   tex_map_t    textures;
+   sprite_map_t sprites;
+
+   static std::string WadToString(const wad_flat_name_t& fname)
+   {
+      int len;
+
+      for (len = 0; len < WAD_NAME && fname[len]; len++)
+      { }
+        
+      return std::string(fname, len);
+   }
+
+   static void DeleteFlat(const flat_map_t::value_type& P)
+      {
+      delete P.second;
+      }
+
+   static void DeleteTex(const tex_map_t::value_type& P)
+      {
+      delete P.second;
+      }
+
+   static void DeleteSprite(const sprite_map_t::value_type& P)
+      {
+      delete P.second;
+      }
+
+   ~ImageCache ()
+      {
+      std::for_each (flats.begin (), flats.end (), DeleteFlat);
+      std::for_each (textures.begin (), textures.end (), DeleteTex);
+      std::for_each (sprites.begin (), sprites.end (), DeleteSprite);
+
+      flats.clear ();
+      textures.clear ();
+      sprites.clear ();
+      }
+
+   Img *GetFlat   (const wad_flat_name_t& fname);
+   Img *GetTex    (const wad_tex_name_t& tname);
+   Img *GetSprite (const wad_ttype_t& type);
+};
+
+
+#endif  /* DO NOT ADD ANYTHING AFTER THIS LINE */
--- yadex-1.7.0.orig/src/version.cc
+++ yadex-1.7.0/src/version.cc
@@ -1,4 +1,4 @@
 // DO NOT EDIT -- generated from VERSION
 
-extern const char *const yadex_source_date = "2003-12-28";
+extern const char *const yadex_source_date = "2011-01-05";
 extern const char *const yadex_version = "1.7.0";
--- yadex-1.7.0.orig/ygd/hexen.ygd
+++ yadex-1.7.0/ygd/hexen.ygd
@@ -108,6 +108,7 @@
 ldt 101 x "?? Scroll right"  "??  Scroll_Texture_Right"
 ldt 102 x "?? Scroll up"     "??  Scroll_Texture_Up"
 ldt 103 x "?? Scroll down"   "??  Scroll_Texture_Down"
+ldt 109 L "?? Force lightng" "??  Light_ForceLightning"
 ldt 110 L "?? Raise light"   "??  Light_RaiseByValue"
 ldt 111 L "?? Lower light"   "??  Light_LowerByValue"
 ldt 112 L "?? Set light"     "??  Light_ChangeToValue"
@@ -136,25 +137,12 @@
 #
 
 st   0 "  Normal"       "Normal"
-st   1 "  Phased light" "light phased"           # FIXME
-st   2 "  Light start"  "lightsequencestart"     # FIXME
-st   3 "  Light specl1" "lightsequencespecial1"  # FIXME
-st   4 "  Light specl2" "lightsequencespecial2"  # FIXME
-st   9 "  Secret"       "Sector counts toward secret count"
+st   1 "  Phased light" "light phased"
+st   2 "  Light start"  "lightsequencestart"
+st   3 "  Light specl1" "lightsequencespecial1"
+st   4 "  Light specl2" "lightsequencespecial2"
 st  26 "  Stairs1"      "Stairs special 1"
 st  27 "  Stairs2"      "Stairs special 2"
-st  40 "  Wind east 1"  "Wind east force 1"
-st  41 "  Wind east 2"  "Wind east force 2"
-st  42 "  Wind east 3"  "Wind east force 3"
-st  43 "  Wind north 1" "Wind north force 1"
-st  44 "  Wind north 2" "Wind north force 2"
-st  45 "  Wind north 3" "Wind north force 3"
-st  46 "  Wind south 1" "Wind south force 1"
-st  47 "  Wind south 2" "Wind south force 2"
-st  48 "  Wind south 3" "Wind south force 3"
-st  49 "  Wind west 1"  "Wind west force 1"
-st  50 "  Wind west 2"  "Wind west force 2"
-st  51 "  Wind west 3"  "Wind west force 3"
 st 198 "  Lightning 64" "Indoor lightning, +64 units"
 st 199 "  Lightning 32" "Indoor lightning, +32 units"
 st 200 "  Sky2"         "Use MAPINFO sky2"
@@ -191,17 +179,21 @@
 thinggroup p rgb:4/f/4 "Player"
 thinggroup m rgb:f/0/0 "Monster"
 thinggroup w rgb:f/a/0 "Weapon"
-thinggroup a rgb:8/5/0 "Ammunition"
+thinggroup a rgb:8/5/0 "Mana"
 thinggroup h rgb:2/8/0 "Health & armour"
+thinggroup A rgb:2/8/0 "Artifacts"
+thinggroup q rgb:2/8/0 "Quest items"
 thinggroup b rgb:2/8/0 "Misc. bonus"
 thinggroup k rgb:f/0/f "Key"
 thinggroup P rgb:6/6/c "Plants"
+thinggroup t rgb:6/6/c "Stalagm. & stalact."
+thinggroup g rgb:6/6/c "Gargoyle statues"
+thinggroup T rgb:6/6/c "Table stuff"
+thinggroup D rgb:6/6/c "Dungeon stuff"
 thinggroup d rgb:6/6/c "Misc. decoration"
 thinggroup l rgb:6/6/c "Light source"
-#thinggroup g rgb:6/6/c "Gory decoration"
-#thinggroup c rgb:6/6/c "Corpse"
-thinggroup e rgb:0/b/d "Environment sound"
-thinggroup s rgb:0/b/d "Ambient sound"
+thinggroup s rgb:0/b/d "Sound"
+thinggroup S rgb:0/b/d "Special"
 
 #
 #	Definition of things
@@ -210,56 +202,273 @@
 #	<desc> must not exceed 19 characters.
 #
 
-thing     1 p -   16 "Player 1 start"		PLAY
-thing     2 p -   16 "Player 2 start"		PLAY
-thing     3 p -   16 "Player 3 start"		PLAY
-thing     4 p -   16 "Player 4 start"		PLAY
-thing    11 p -   16 "Deathmatch start"		PLAYF1
-thing    14 p -   16 "Teleport exit"		TELE
+ thing     1 p -   16 "Player 1 start *"        PLAY
+ thing     2 p -   16 "Player 2 start *"        PLAY
+ thing     3 p -   16 "Player 3 start *"        PLAY
+ thing     4 p -   16 "Player 4 start *"        PLAY
+ thing    11 p -   16 "Deathmatch start"        PLAYF1
+ thing    14 p -   16 "Teleport exit"           TELE
+ thing  9100 p -   16 "Player 5 start *"        PLAY
+ thing  9101 p -   16 "Player 6 start *"        PLAY
+ thing  9102 p -   16 "Player 7 start *"        PLAY
+ thing  9103 p -   16 "Player 8 start *"        PLAY
 
-thing    31 m -   32 "Demon"			DEMN
+
+thing    31 m -   32 "Chaos serpent"       DEMN
+thing    34 m -   40 "Reiver"          WRTH
 thing   107 m -   20 "Centaur"			CENT
+thing   114 m -   44 "Dark bishop"     BISH
 thing   115 m -   20 "Centaur leader"		CENTF
-thing   120 m -   17 "Serpent leader"		SSPTK	# Not too sure...
-thing   121 m -   17 "Serpent"			SSDV	# Not too sure...
-thing  8020 m -   22 "Ice guy"			ICEY
+thing   120 m -   17 "Stalker leader"      SSPTK
+thing   121 m -   17 "Stalker"         SSDV
+thing   254 m -   40 "Death wyvern *"      DRAG
+thing  8020 m -   22 "Wendigo"         ICEY
+thing  8080 m -   64 "Chaos serpent (gas)" DEM2
+thing 10011 m -   40 "Reiver leader"       WRTH
 thing 10030 m -   25 "Ettin"			ETTN
-thing 10060 m -   20 "Fire demon"		FDMN
-
-thing    10 w -   17 "Serpent staff"		WCSS   # Cleric
-thing    53 w -   17 "Frost chards"		WMCS   # Mage
-thing  8010 w -   17 "Timon's axe"		WFAX   # Fighter
+thing 10060 m -   20 "Fire gargoyle"       FDMN
+thing 10080 m -   80 "Heresiarch"      SORC
+thing 10100 m -   32 "Zedek (fighter)"     PLAYA8
+thing 10101 m -   32 "Traductus (cleric)"  CLERA8
+thing 10102 m -   32 "Menelkir (mage)"     MAGEA8
+thing 10200 m -   20 "Korax"           KORX
+
+thing    10 w -   17 "Serpent staff"       WCSS
+thing    12 w -   20 "Quietus blade"       WFR1
+thing    13 w -   20 "Quietus guard"       WFR2
+thing    16 w -   20 "Quietus hilt"        WFR3
+thing    18 w -   20 "Wraithverge head"        WCH1
+thing    19 w -   20 "Wraithverge center"  WCH2
+thing    20 w -   20 "Wraithverge grip"        WCH3
+thing    21 w -   20 "Bloodscourge head"   WMS1
+thing    22 w -   20 "Bloodscourge center" WMS2
+thing    23 w -   20 "Bloodscourge grip"   WMS3
+thing    53 w -   17 "Frost chards"        WMCS
+thing   123 w -   10 "Hammer of retributn" WFHM
+thing  8009 w -   10 "Firestorm"       WCFM
+thing  8010 w -   17 "Timon's axe"     WFAX
+thing  8040 w -   20 "Arc of death"        WMLG
 
 thing   122 a -   17 "Blue manna"		MAN1
 thing   124 a -   17 "Green manna"		MAN2
 thing  8004 a -   17 "Combined manna"		MAN3
 
 thing    81 h -   17 "Crystal vial"		PTN1
-thing    82 h -   17 "Quartz flask"		PTN2
-thing  8000 h -   17 "Flechette"		PSBG
+thing  8005 h -   10 "Mesh armor"      ARM1
+thing  8006 h -   20 "Falcon shield"       ARM2
 thing  8007 h -   17 "Platinum helmet"		ARM3
+thing  8008 h -   20 "Amulet of warding"   ARM4
 
-thing   314 k -   17 "Stone (?) key"		KEY7
+thing    30 A -   20 "Porkalator"      ARTIPORK
+thing    32 A -   20 "Mystic urn"      ARTISPHL
+thing    33 A -   20 "Torch"           ARTITRCH
+thing    36 A -   20 "Chaos device"        ARTIATLP
+thing    82 A -   17 "Quartz flask"        PTN2
+thing    83 A -   20 "Wings of wrath"      SOAR
+thing    84 A -   20 "Icon of defender"        INVU
+thing    86 A -   15 "Dark servant"        ARTISUMN
+thing  8000 A -   17 "Flechette"       PSBG
+thing  8002 A -   20 "Boots of speed"      ARTISPED
+thing  8003 A -   20 "Krater of might"     ARTIBMAN
+thing  8041 A -   20 "Dragonskin bracers"  ARTIBRAC
+thing 10040 A -   20 "Banishment device"   ARTITELO
+thing 10110 A -   20 "Disc of repulsion"   ARTIBLST
+thing 10120 A -   20 "Mystic ambient inc"  ARTIHRAD
+
+thing  9002 q -   20 "Yorick's skull"      ARTISKLL
+thing  9003 q -   20 "Heart of D'Sparil"   ARTIBGEM
+thing  9004 q -   20 "Ruby planet"     ARTIGEMR
+thing  9005 q -   20 "Emerald planet 1"        ARTIGEMG
+thing  9006 q -   20 "Sapphire planet 1"   ARTIGEMB
+thing  9007 q -   20 "Daemon codex"        ABK1
+thing  9008 q -   20 "Liber oscura"        ABK2
+thing  9009 q -   20 "Emerald planet 2"        ARTIGMG2
+thing  9010 q -   20 "Sapphire planet 2"   ARTIGMB2
+thing  9014 q -   20 "Flame mask"      ARTISKL2
+thing  9015 q -   20 "Glaive seal"     ARTIFWEP
+thing  9016 q -   20 "Holy relic"      ARTICWEP
+thing  9017 q -   20 "Sigil of the Magus"  ARTIMWEP
+thing  9018 q -   20 "Clock gear 1"        ARTIGEAR
+thing  9019 q -   20 "Clock gear 2"        ARTIGER2
+thing  9020 q -   20 "Clock gear 3"        ARTIGER3
+thing  9021 q -   20 "Clock gear 4"        ARTIGER4
+
+thing  8030 k -   10 "Steel key"       KEY1
+thing  8031 k -   10 "Cave key"            KEY2
+thing  8032 k -   10 "Axe key"         KEY3
+thing  8033 k -   10 "Fire key"            KEY4
+thing  8034 k -   10 "Emerald key"     KEY5
+thing  8035 k -   10 "Dungeon key"     KEY6
+thing  8036 k -   10 "Silver key"      KEY7
+thing  8037 k -   10 "Rusted key"      KEY8
+thing  8038 k -   10 "Horn key"            KEY9
+thing  8039 k -   10 "Swamp key"       KEYA
+thing  8200 k -   10 "Castle key"      KEYB
 
+thing    24 P -   20 "Tree trunk (brown)"  TRE1
+thing    25 P -   20 "Tree trunk (brownD)" TRE1
 thing    26 P -   17 "Swamp tree tall"		TRE2
 thing    27 P -   17 "Swamp tree short"		TRE3
+thing    28 P -   20 "Tree stump (splint)" STM1
+thing    29 P -   20 "Tree stump"      STM2
+thing    39 P -   20 "Mushroom (large, L)" MSH1
+thing    40 P -   20 "Mushroom (large, R)" MSH2
+thing    41 P -   20 "Mushroom (med, L)"   MSH3
+thing    42 P -   20 "Mushroom (small, R)" MSH4
+thing    44 P -   20 "Mushroom (small)"        MSH5
+thing    45 P -   20 "Mushroom (small, F)" MSH6
+thing    46 P -   20 "Mushroom (small, B)" MSH7
+thing    47 P -   20 "Mushroom (small, M)" MSH8
+thing    60 P -   20 "Vine"            TRE3
 thing    78 P -   17 "Tree leaning right"	TRE4
 thing    79 P -   17 "Tree leaning left"	TRE5
 thing    80 P -   17 "Gnarled tree right"	TRE6
 thing    87 P -   17 "Gnarled tree left"	TRE7
+thing   113 P -   10 "Blowing leaves"      LEF1
 thing  8062 P -   17 "Dead tree"		TRDT
 thing  8068 P -   17 "Conic tree"		XMAS
 
-thing    48 d -   17 "Stalactite+gmite"		SGMP
-thing    72 d -   17 "Statue"			STT2
-thing    74 d -   17 "Short statue"		STT4
+thing  8101 P -   20 "Shrub (small)"       SHB1
+thing  8102 P -   20 "Shrub (large)"       SHB2
+thing  8103 P -   20 "Bucket (hanging)"        BCKT
+thing  8104 P -   20 "Mushroom (explodng)" SHRM
+
+thing    48 t -   17 "Stalactite+gmite"        SGMP
+thing    49 t -   20 "Stalagmite (large)"  SGM1
+thing    50 t -   20 "Stalagmite (medium)" SGM2
+thing    51 t -   20 "Stalagmite (small)"  SGM3
+thing    52 t -   20 "Stalactite (large)"  SLC1
+thing    56 t -   20 "Stalactite (medium)" SLC2
+thing    57 t -   20 "Stalactite (small)"  SLC3
+thing    89 t -   20 "Ice stalactite(lrg)" ICT1
+thing    90 t -   20 "Ice stalactite(med)" ICT2
+thing    91 t -   20 "Ice stalactite(sml)" ICT3
+thing    92 t -   20 "Ice stalactite(tny)" ICT4
+thing    93 t -   20 "Ice stalagmite(lrg)" ICM1
+thing    94 t -   20 "Ice stalagmite(med)" ICM2
+thing    95 t -   20 "Ice stalagmite(sml)" ICM3
+thing    96 t -   20 "Ice stalagmite(tny)" ICM4
+
+thing     5 g -   20 "Gargoyle statue w/s" STTW
+thing    72 g -   17 "Stone gargoyle tall" STT2
+thing    73 g -   20 "Ice gargoyle tall"   STT3
+thing    74 g -   17 "Stone gargoyle shrt" STT4
+thing    76 g -   20 "Ice gargoyle short"  STT5
+thing  8044 g -   20 "Wooden gargoyle tal" GAR1
+thing  8045 g -   20 "Fire gargoyle tall"  GAR2
+thing  8046 g -   20 "Red gargoyle tall"   GAR3
+thing  8047 g -   20 "Wooden gargoyle tal" GAR4
+thing  8048 g -   20 "Metal gargoyle tall" GAR5
+thing  8049 g -   20 "Fire gargoyle short" GAR6
+thing  8050 g -   20 "Red gargoyle short"  GAR7
+thing  8051 g -   20 "Wooden gargoyle srt" GAR8
+thing  8052 g -   20 "Metal gargoyle shrt" GAR9
+thing  9011 g -   20 "Gargoyle statue"     STWN
+
+thing  8500 T -   20 "Stein (tall)"        TST1
+thing  8501 T -   20 "Stein (short)"       TST2
+thing  8502 T -   20 "Candle w/spider web" TST3
+thing  8503 T -   20 "Candle (short)"      TST4
+thing  8504 T -   20 "Candle (tall)"       TST5
+thing  8505 T -   20 "Goblet (spilled)"        TST6
+thing  8506 T -   20 "Goblet (tall)"       TST7
+thing  8507 T -   20 "Goblet (short)"      TST8
+thing  8508 T -   20 "Goblet w/silver bnd" TST9
+thing  8509 T -   20 "Meat cleaver"        TST0
+
+thing    61 D -   20 "Corpse impaled"      CPS1
+thing    62 D -   20 "Corpse sleeping"     CPS2
+thing    71 D -   20 "Corpse hung legs"        CPS3
+thing   108 D -   20 "Corpse hung"     CPS4
+thing   109 D -   20 "Corpse bleeding"     CPS5
+thing   110 D -   20 "Corpse chained"      CPS6
+thing   111 D -   10 "Pool of blood"       BDPL
+thing  8067 D -   20 "Iron maiden"     IRON
+thing  8071 D -   20 "Chain (short)"       CHNS
+thing  8072 D -   20 "Chain (long)"        CHNSB0
+thing  8073 D -   20 "Chain heart on hook" CHNSC0
+thing  8074 D -   20 "Chain w/large hook"  CHNSD0
+thing  8075 D -   20 "Chain w/small hook"  CHNSE0
+thing  8076 D -   20 "Chain w/spiked ball" CHNSF0
+thing  8077 D -   20 "Chain skull on hook" CHNSG0
+
+thing     6 d -   20 "Rock w/moss (tiny)"  RCK1
+thing     7 d -   20 "Rock w/moss (small)" RCK2
+thing     9 d -   20 "Rock w/moss (medium)"    RCK3
+thing    15 d -   20 "Rock w/moss (large)" RCK4
+thing    37 d -   20 "Stump w/moss (short)"    STM3
+thing    38 d -   20 "Stump w/moss (tall)" STM4
+thing    58 d -   20 "Moss (three strands)"    MSS1
+thing    59 d -   20 "Moss (one strand)"   MSS2
+thing    63 d -   20 "Tombstone (R.I.P.)"  TMS1
+thing    64 d -   20 "Tombstone (Shane)"   TMS2
+thing    65 d -   20 "Tombstone (large cross)" TMS3
+thing    66 d -   20 "Tombstone (Brian R.)"    TMS4
+thing    67 d -   20 "Tombstone (circular cross)"  TMS5
+thing    68 d -   20 "Tombstone (small cross on pedestal)" TMS6
+thing    69 d -   20 "Tombstone (Brian P.)"    TMS7
 thing    77 d -   17 "Banner"			BNR1
 
-thing    54 l -   17 "Torch"			WLTR
-thing  8061 l -   17 "FIXME"			BRTR
-
-thing   314 e -   17 "Bogus sound"
-
-thing   314 s -   17 "Bogus sound"
 
+thing    88 d -   20 "Log"         LOGG
+thing    97 d -   20 "Rock formation (large, brown)"   RKBL
+thing    98 d -   20 "Rock formation (small, brown)"   RKBS
+thing    99 d -   20 "Rock formation (small, gray)"    RKBK
+thing   100 d -   20 "Rubble (large)"      RBL1
+thing   101 d -   20 "Rubble (small)"      RBL2
+thing   102 d -   20 "Rubble (medium)"     RBL3
+thing   103 d -   20 "Vase on pedestal"        VASE
+thing   104 d -   20 "Pot (tall, skinny) *"    POT1
+thing   105 d -   20 "Pot (medium, skinny) *"  POT2
+thing   106 d -   20 "Pot (short, chipped) *"  POT3
+thing   140 d -   20 "Sparkling red smoke" TSMK
+thing  8064 d -   20 "Suit of armor *"     SUIT
+thing  8065 d -   40 "Bell"            BBLL
+thing  8100 d -   20 "Barrel"          BARL
+thing  9012 d -   20 "Pedestal"            GMPD
+thing 10001 d -   20 "Fog (small) *"       FOGS
+thing 10002 d -   20 "Fog (medium) *"      FOGM
+thing 10003 d -   20 "Fog (large) *"       FOGL
+thing 10090 d -   20 "Spike (down)"        TSPKC0
+thing 10091 d -   20 "Spike (up)"      TSPK
+
+thing    17 l -   20 "Chandelier w/flame"  CDLR
+thing    54 l -   17 "Wall torch w/flame"  WLTR
+thing    55 l -   20 "Wall torch"      WLTRI0
+thing   116 l -   10 "Brazier w/flame"     TWTR
+thing   117 l -   10 "Brazier"         TWTRI0
+thing   119 l -   20 "Candles"         CNDL
+thing  8042 l -   20 "Minotaur statue f"   FBUL
+thing  8043 l -   20 "Minotaur statue"     FBULH0
+thing  8060 l -   20 "Fire skull"      FSKL
+thing  8061 l -   17 "Brazier w/flame sm"  BRTR
+thing  8063 l -   20 "Chandelier"      CDLRD0
+thing  8066 l -   20 "Candle (blue)"       CAND
+thing  8069 l -   20 "Cauldron (w/flame)"  CDRNB0
+thing  8070 l -   20 "Cauldron"            CDRN
+thing 10500 l -   20 "Flame (small, t) *"  FFSM
+thing 10501 l -   20 "Flame (small, cnt)"  FFSMC0
+thing 10502 l -   20 "Flame (large, t) *"  FFLG
+thing 10503 l -   20 "Flame (large, cnt)"  FFLGF0
+
+thing  1400 s -   20 "Stone"           TELE
+thing  1401 s -   20 "Heavy"           TELE
+thing  1402 s -   20 "Metal"           TELE
+thing  1403 s -   20 "Creak"           TELE
+thing  1404 s -   20 "Silent"          TELE
+thing  1405 s -   20 "Lava"            TELE
+thing  1406 s -   20 "Water"           TELE
+thing  1407 s -   20 "Ice"         TELE
+thing  1408 s -   20 "Earth crack"     TELE
+thing  1409 s -   20 "Metal2"          TELE
+thing  1410 s -   20 "Wind blowing"        TELE
+
+thing   118 S -   10 "Magic step"      TLGL
+thing  3000 S -   20 "Polyobject anchor"   ICPRD0
+thing  3001 S -   20 "Start spot"      SBFXH0
+thing  3002 S -   20 "Start spot w/crush"  SBFXC0
+thing  9001 S -   10 "Map spot *"      TELEC0
+thing  9013 S -   10 "Map spot w/gravity"  TELED0
+thing 10000 S -   20 "Spawn fog *"     SPIRK0
+thing 10225 S -   20 "Spawn bat *"     ABATC3C7
 
--- yadex-1.7.0.orig/debian/copyright
+++ yadex-1.7.0/debian/copyright
@@ -0,0 +1,45 @@
+This package was debianized by:
+
+    Brian Manning <brian@portaboom.com> on Tue, 04 Jan 2011 18:12:36 -0800
+
+It was downloaded from:
+
+    http://www.teaser.fr/~amajorel/yadex/
+
+Upstream Author(s):
+
+    AndrÃ© Majorel <amajorel@teaser.fr>
+
+Copyright:
+
+    Andrew Apted 2000-2001
+    AndrÃ© Majorel 1997-2003
+    Matthew W. Miller 2000
+    RaphaÃ«l Quinet (copyright date unknown)
+    Brendon Wyber (copyright date unknown)
+
+License:
+
+    This package is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This package is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this package; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+
+On Debian systems, the complete text of the GNU General
+Public License version 2 can be found in `/usr/share/common-licenses/GPL-2'.
+
+The Debian packaging is:
+
+    Copyright (C) 2011 Brian Manning <brian@portaboom.com>
+
+and is licensed under the GPL version 2, 
+see `/usr/share/common-licenses/GPL-2'.
--- yadex-1.7.0.orig/debian/postrm.ex
+++ yadex-1.7.0/debian/postrm.ex
@@ -0,0 +1,37 @@
+#!/bin/sh
+# postrm script for yadex
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <postrm> `remove'
+#        * <postrm> `purge'
+#        * <old-postrm> `upgrade' <new-version>
+#        * <new-postrm> `failed-upgrade' <old-version>
+#        * <new-postrm> `abort-install'
+#        * <new-postrm> `abort-install' <old-version>
+#        * <new-postrm> `abort-upgrade' <old-version>
+#        * <disappearer's-postrm> `disappear' <overwriter>
+#          <overwriter-version>
+# for details, see http://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    purge|remove|upgrade|failed-upgrade|abort-install|abort-upgrade|disappear)
+    ;;
+
+    *)
+        echo "postrm called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
--- yadex-1.7.0.orig/debian/postinst.ex
+++ yadex-1.7.0/debian/postinst.ex
@@ -0,0 +1,39 @@
+#!/bin/sh
+# postinst script for yadex
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <postinst> `configure' <most-recently-configured-version>
+#        * <old-postinst> `abort-upgrade' <new version>
+#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
+#          <new-version>
+#        * <postinst> `abort-remove'
+#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
+#          <failed-install-package> <version> `removing'
+#          <conflicting-package> <version>
+# for details, see http://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    configure)
+    ;;
+
+    abort-upgrade|abort-remove|abort-deconfigure)
+    ;;
+
+    *)
+        echo "postinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
--- yadex-1.7.0.orig/debian/preinst.ex
+++ yadex-1.7.0/debian/preinst.ex
@@ -0,0 +1,35 @@
+#!/bin/sh
+# preinst script for yadex
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <new-preinst> `install'
+#        * <new-preinst> `install' <old-version>
+#        * <new-preinst> `upgrade' <old-version>
+#        * <old-preinst> `abort-upgrade' <new-version>
+# for details, see http://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    install|upgrade)
+    ;;
+
+    abort-upgrade)
+    ;;
+
+    *)
+        echo "preinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
--- yadex-1.7.0.orig/debian/control
+++ yadex-1.7.0/debian/control
@@ -0,0 +1,21 @@
+Source: yadex
+Section: games
+Priority: extra
+Maintainer: Brian Manning <brian@portaboom.com>
+Build-Depends: debhelper (>= 7), autotools-dev
+Standards-Version: 3.8.1
+Homepage: http://www.teaser.fr/~amajorel/yadex/
+
+Package: yadex
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Description: adex is a Doom level (wad) editor for Unix systems running X.
+ Yadex supports Doom alpha, Doom beta, Doom, Ultimate Doom, Final Doom, 
+ Doom II, Heretic and also, in a more or less limited way, Hexen and Strife. 
+ It is available under the terms of the GPL.
+ .
+ Yadex is descended from DEU 5.21. Therefore, as you might expect, it's a
+ rather low-level editor that requires you to take care of a lot of detail but
+ on the flip side allows you to control very precisely what you are doing. In
+ addition, it has many advanced functions that DEU didn't have, to make certain
+ tedious tasks easy.
--- yadex-1.7.0.orig/debian/watch.ex
+++ yadex-1.7.0/debian/watch.ex
@@ -0,0 +1,23 @@
+# Example watch control file for uscan
+# Rename this file to "watch" and then you can run the "uscan" command
+# to check for upstream updates and more.
+# See uscan(1) for format
+
+# Compulsory line, this is a version 3 file
+version=3
+
+# Uncomment to examine a Webpage
+# <Webpage URL> <string match>
+#http://www.example.com/downloads.php yadex-(.*)\.tar\.gz
+
+# Uncomment to examine a Webserver directory
+#http://www.example.com/pub/yadex-(.*)\.tar\.gz
+
+# Uncommment to examine a FTP server
+#ftp://ftp.example.com/pub/yadex-(.*)\.tar\.gz debian uupdate
+
+# Uncomment to find new files on sourceforge, for devscripts >= 2.9
+# http://sf.net/yadex/yadex-(.*)\.tar\.gz
+
+# Uncomment to find new files on GooglePages
+# http://example.googlepages.com/foo.html yadex-(.*)\.tar\.gz
--- yadex-1.7.0.orig/debian/changelog
+++ yadex-1.7.0/debian/changelog
@@ -0,0 +1,5 @@
+yadex (1.7.0-1) unstable; urgency=low
+
+  * Initial release
+
+ -- Brian Manning <brian@portaboom.com>  Tue, 04 Jan 2011 18:12:36 -0800
--- yadex-1.7.0.orig/debian/docs
+++ yadex-1.7.0/debian/docs
@@ -0,0 +1,4 @@
+FAQ
+README
+TODO
+doc/*
--- yadex-1.7.0.orig/debian/menu.ex
+++ yadex-1.7.0/debian/menu.ex
@@ -0,0 +1,2 @@
+?package(yadex):needs="X11|text|vc|wm" section="Applications/see-menu-manual"\
+  title="yadex" command="/usr/bin/yadex"
--- yadex-1.7.0.orig/debian/compat
+++ yadex-1.7.0/debian/compat
@@ -0,0 +1 @@
+7
--- yadex-1.7.0.orig/debian/prerm.ex
+++ yadex-1.7.0/debian/prerm.ex
@@ -0,0 +1,38 @@
+#!/bin/sh
+# prerm script for yadex
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <prerm> `remove'
+#        * <old-prerm> `upgrade' <new-version>
+#        * <new-prerm> `failed-upgrade' <old-version>
+#        * <conflictor's-prerm> `remove' `in-favour' <package> <new-version>
+#        * <deconfigured's-prerm> `deconfigure' `in-favour'
+#          <package-being-installed> <version> `removing'
+#          <conflicting-package> <version>
+# for details, see http://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    remove|upgrade|deconfigure)
+    ;;
+
+    failed-upgrade)
+    ;;
+
+    *)
+        echo "prerm called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
--- yadex-1.7.0.orig/debian/README.Debian
+++ yadex-1.7.0/debian/README.Debian
@@ -0,0 +1,6 @@
+yadex for Debian
+----------------
+
+<possible notes regarding this package - if none, delete this file>
+
+ -- Brian Manning <brian@portaboom.com>  Tue, 04 Jan 2011 18:12:36 -0800
--- yadex-1.7.0.orig/debian/rules
+++ yadex-1.7.0/debian/rules
@@ -0,0 +1,98 @@
+#!/usr/bin/make -f
+# -*- makefile -*-
+# Sample debian/rules that uses debhelper.
+# This file was originally written by Joey Hess and Craig Small.
+# As a special exception, when this file is copied by dh-make into a
+# dh-make output file, you may use that output file without restriction.
+# This special exception was added by Craig Small in version 0.37 of dh-make.
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+
+# These are used for cross-compiling and for saving the configure script
+# from having to guess our platform (since we know it already)
+DEB_HOST_GNU_TYPE   ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)
+DEB_BUILD_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
+ifneq ($(DEB_HOST_GNU_TYPE),$(DEB_BUILD_GNU_TYPE))
+CROSS= --build $(DEB_BUILD_GNU_TYPE) --host $(DEB_HOST_GNU_TYPE)
+else
+CROSS= --build $(DEB_BUILD_GNU_TYPE)
+endif
+
+
+
+config.status: configure
+	dh_testdir
+	# Add here commands to configure the package.
+	./configure --prefix=$(CURDIR)/debian/yadex
+
+
+build: build-stamp
+
+build-stamp:  config.status 
+	dh_testdir
+
+	# Add here commands to compile the package.
+	$(MAKE)
+	#docbook-to-man debian/yadex.sgml > yadex.1
+
+	touch $@
+
+clean: 
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp 
+
+	# Add here commands to clean up after the build process.
+	[ ! -f obj/0/Makefile.config ] || $(MAKE) clean
+
+	dh_clean 
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_prep  
+	dh_installdirs
+
+	# Add here commands to install the package into debian/yadex.
+	$(MAKE) install
+
+
+# Build architecture-independent files here.
+binary-indep: install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: install
+	dh_testdir
+	dh_testroot
+	dh_installchangelogs CHANGES
+	dh_installdocs
+	dh_installexamples
+#	dh_install
+#	dh_installmenu
+#	dh_installdebconf
+#	dh_installlogrotate
+#	dh_installemacsen
+#	dh_installpam
+#	dh_installmime
+#	dh_python
+#	dh_installinit
+#	dh_installcron
+#	dh_installinfo
+	dh_installman
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+#	dh_perl
+#	dh_makeshlibs
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install 
